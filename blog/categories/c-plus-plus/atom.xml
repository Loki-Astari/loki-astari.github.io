<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Loki Astari]]></title>
  <link href="http://lokiastari.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://lokiastari.com/"/>
  <updated>2016-05-25T09:21:14-07:00</updated>
  <id>http://lokiastari.com/</id>
  <author>
    <name><![CDATA[Loki Astari]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Socket Read/Write]]></title>
    <link href="http://lokiastari.com/blog/2016/04/09/socket-read/"/>
    <updated>2016-04-09T21:11:25-07:00</updated>
    <id>http://lokiastari.com/blog/2016/04/09/socket-read</id>
    <content type="html"><![CDATA[<h2>Checking read/write success</h2>

<p>The <code>read()</code> and <code>write()</code> command can fail in a couple of ways but can also succeed without reading/writing all the data, a common mistake is not to check the amount of data read/written from/to a stream. Interestingly not all error condition are fatal and reading/writing can potentially be resumed after an error.</p>

<h2>Read</h2>

<p>To understand if you have read all the information that is available on a stream you need to define a communication protocol (like HTTP). For the first version of this server the protocol is very simple. Messages are passed as strings (not null terminated) and the end of the message is marked by closing the write stream. Thus a client can send one message and receive one reply with each connection it makes.</p>

<p>```c getMessage()
/<em>
 * Returns:     0   EOM reached.
 *                  The message is complete. There is no more data to be read.
 *              >0  Message data has been read (and a null terminator added).
 *                  The value is the number of bytes read from the stream
 *                  You should call getMessage() again to get the next section of the message.
 *                  Note: the message is terminated when 0 is returned.
 *              -1  An error occured.
 </em>/
int getMessage(int socketId, char* buffer, std::ssize_t size)
{</p>

<pre><code>std::ssize_t     dataRead = 0;
std::ssize_t     dataMax  = size - 1;

while(dataRead &lt; dataMax)
{
    ssize_t get = read(socketId, buffer + dataRead, size - dataRead);
    if (get == -1)
    {
        return -1;
    }
    if (get == 0)
    {
        break;
    }
    dataRead += get;
}
buffer[dataRead] = '\0';
return dataRead;
</code></pre>

<p>}
```</p>

<h3>Read Errors</h3>

<p>This initial version treats all <code>read()</code> errors as unrecoverable and <code>getMessage()</code> return an error state. But not all error codes need to result in a failure. So in this section I will go through some of the error codes and give some potentially actions. In a subsequent articles I may revise these actions as we cover more complex ways of interacting with sockets.</p>

<p>The following errors are the result of programming bugs and should not happen in production.</p>

<pre><code>[EBADF]            fildes is not a valid file or socket descriptor open for reading.
[EFAULT]           Buf points outside the allocated address space.
[EINVAL]           The pointer associated with fildes was negative.
[ENXIO]            A requested action cannot be performed by the device.
</code></pre>

<p>If they do happen in production there is no way to correct for them pragmatically because the error has happened in another part of the code unassociated with this function.</p>

<p>One could argue that because these should never happen the application can abort, but for now we will settle for the read operation aborting with an error code. If we wrap this in a C++ class to control the state of the socket then exceptions may be more appropriate and we will look into that approach in a subsequent article.</p>

<p>The following errors are potentially recoverable from.</p>

<!-- http://stackoverflow.com/questions/8471577/linux-tcp-connect-failure-with-etimedout -->


<pre><code>[EIO]              An I/O error occurred while reading from the file system.
[ENOBUFS]          An attempt to allocate a memory buffer fails.
[ENOMEM]           Insufficient memory is available.
[ETIMEDOUT]        A transmission timeout occurs during a read attempt on a socket.
</code></pre>

<p>But in reality recovering from them within the context of a read operation is not practical (you need to recover from these operations at a point were resource are controlled or user interaction is possible). So for now we will abort the read operation with an error code (we will revisit this in a later article).</p>

<p>The following error codes means that no more data will be available because the connection has been interrupted.</p>

<!-- http://stackoverflow.com/questions/2974021/what-does-econnreset-mean-in-the-context-of-an-af-local-socket -->


<!-- http://stackoverflow.com/questions/900042/what-causes-the-enotconn-error -->


<pre><code>[ECONNRESET]       The connection is closed by the peer during a read attempt on a socket.
[ENOTCONN]         A read is attempted on an unconnected socket.
</code></pre>

<p>How the application reacts to a broken connection depends on the communication protocol. For the simple protocol defined above we can return any data that has been retrieved from the socket and then indicating to the calling code that we have reached the end of the message (we will revisit this in a later article). This is probably the most iffy decision in handling error codes and returning an error code could be more appropriate but I want to illustrate that we can potentially continue depending on the situation.</p>

<p>The following error codes are recoverable from.</p>

<pre><code>[EAGAIN]           The file was marked for non-blocking I/O, and no data were ready to be read.
</code></pre>

<p>These error codes are generated when you have a non-blocking stream. In a future article we will discuss how to take advantage of non-blocking streams.</p>

<pre><code>[EINTR]            A read from a slow device was interrupted before any data arrived by the delivery of a signal.
</code></pre>

<p>The exact action that you take will depend on your application (like doing some useful work) but for our simple application simply re-trying the read operation will be the standard action. Again we will come back to this, but taking advantage of timeouts will require a slightly more sophisticated approach rather than using the sockets API directly.</p>

<blockquote><p><strong>EINTR:</strong><br/>
An important note about signals. There are a lot of signals that are non leathal and will result in this EINTR error code. But one should note that leathal signals like SIGINT by default will kill the application and thus will not cause this error code (as the call to read() will never return).</p>

<p>But you can override the SIGINT signal handler and a allow your application to continue and at this point your read operation will recieve this error. How your code interacts with signals like SIGINT is beyond the scope of this article and it will be discussed just like other signals.</p></blockquote>

<p>```c getMessage() Improved
/<em>
 * Returns:     0   EOM reached.
 *                  There is no data in the buffer.
 *              >0  Message data has been read.
 *                  If the buffer is full then it is not null terminated.
 *                  If the buffer is partially full then it is null terminated
 *                  and the next call to get getMessage() will return 0.
 *              &lt;0  An error occured.
 </em>/
int getMessage(int socketId, char* buffer, std::ssize_t size)
{</p>

<pre><code>std::ssize_t     dataRead = 0;
std::ssize_t     dataMax  = size - 1;

while(dataRead &lt; dataMax)
{
    ssize_t get = read(socketId, buffer + dataRead, size - dataRead);
    if (get == -1)
    {
        switch(errno)
        {
            case EBADF:
            case EFAULT:
            case EINVAL:
            case ENXIO:
                // Fatal error. Programming bug
                return -3;
            case EIO:
            case ENOBUFS:
            case ENOMEM:
                // Resource aquisition failure or device error
                // Can't recover from here so indicate failure
                // and exit
                return -2;
            case ETIMEDOUT:
            case EAGAIN:
            case EINTR:
                // Temporrary error.
                // Simply retry the read.
                continue;
            case ECONNRESET:
            case ENOTCONN:
                // Connection broken.
                // Return the data we have available and exit
                // as if the connection was closed correctly.
                get = 0;
                break;
            default:
                return -1;
        }
    }
    if (get == 0)
    {
        break;
    }
    dataRead += get;
}
buffer[dataRead] = '\0';
return dataRead;
</code></pre>

<p>}
```</p>

<h2>Write</h2>

<p>The <code>write()</code> has exactly the same scenario as <code>read()</code>.</p>

<p>The following errors are the reuls of programming bugs and should not happen in production.</p>

<pre><code> [EINVAL]           The pointer associated with fildes is negative.
 [EBADF]            fildes is not a valid file descriptor open for writing.
 [ECONNRESET]       A write is attempted on a socket that is not connected.
 [ENXIO]            A request is made of a nonexistent device, or the request is outside the capabilities of the device.
 [EPIPE]            An attempt is made to write to a socket of type SOCK_STREAM that is not connected to a peer socket.
</code></pre>

<p>The following errors are potentially recoverable bugs. Though recovering from them requires some form of awarness of the context that is not provided at the read level. So we must generate an error to stop reading and allow the caller to sort out the problem.</p>

<pre><code> [EDQUOT]           The user's quota of disk blocks on the file system containing the file is exhausted.
 [EFBIG]            An attempt is made to write a file that exceeds the process's file size limit or the maximum file size.
 [EIO]              An I/O error occurs while reading from or writing to the file system.
 [ENETDOWN]         A write is attempted on a socket and the local network interface used to reach the destination is down.
 [ENETUNREACH]      A write is attempted on a socket and no route to the network is present.
 [ENOSPC]           There is no free space remaining on the file system containing the file.
</code></pre>

<p>The following error codes are recoverable from and we covered them above in the section on <code>read()</code>.</p>

<pre><code> [EAGAIN]           The file is marked for non-blocking I/O, and no data could be written immediately.
 [EINTR]            A signal interrupts the write before it could be completed.
</code></pre>

<p>The resulting put function then looks like this.</p>

<p>```c putMessage() Improved
/<em>
 * Returns:
 *              >0  Indicates success and the number of bytes written.
 *              &lt;0  Indicates failure.
 </em>/
int putMessage(int socketId, char* buffer, ssize_t size)
{</p>

<pre><code>ssize_t     dataWritten = 0;

while(dataWritten &lt; size)
{
    ssize_t put = write(socketId, buffer + dataWritten, size - dataWritten);
    if (put == -1)
    {
        switch(errno)
        {
            case EINVAL:
            case EBADF:
            case ECONNRESET:
            case ENXIO:
            case EPIPE:
                // Fatal error. Programming bug
                return -3;
            case EDQUOT:
            case EFBIG:
            case EIO:
            case ENETDOWN:
            case ENETUNREACH:
            case ENOSPC:
                // Resource aquisition failure or device error
                // Can't recover from here so indicate failure
                // and exit
                return -2;
            case EAGAIN:
            case EINTR:
                // Temporrary error.
                // Simply retry the read.
                continue;
            default:
                return -1;
        }
    }
    dataWritten += put;
}
return dataWritten;
</code></pre>

<p>}
```</p>

<h1>Summary</h1>

<p>This article has shown the most important error that people skip over when reading and writing to a socket: <strong>Not all the data was transported at the same time</strong>. The read and write command may only read/write a portion of the data that you wanted to send/receive and thus you must check the amount that actually was sent/received.</p>

<p>The next most important point is that not all error codes are fatal (most people actually check these) <strong>but</strong> an interrupt (EINTR) can be relatively common and you can continue reading after it has happened.</p>

<h1>Inspiration</h1>

<ul>
<li>2015-Jun-25 <a href="http://codereview.stackexchange.com/q/94608/507">Impromptu TCP sender/receiver</a></li>
<li>2015-Jul-03 <a href="http://codereview.stackexchange.com/q/95638/507">Raw Text TCP Client v3</a></li>
<li>2015-Dec-20 <a href="http://codereview.stackexchange.com/q/114551/507">Server / client desynchronisation of messages </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Socket Programming in C]]></title>
    <link href="http://lokiastari.com/blog/2016/04/08/socket-programming-in-c-version-1/"/>
    <updated>2016-04-08T09:47:01-07:00</updated>
    <id>http://lokiastari.com/blog/2016/04/08/socket-programming-in-c-version-1</id>
    <content type="html"><![CDATA[<p>Building a simple client/server application is the common first internet based applications developers attempt. These applications are built on top of the socket communication library, but socket programming in C++ is not obvious as there are no standard libraries and thus you have to fall back to the C API. The closest &ldquo;standardish&rdquo; sort of thing we have is <a href="http://www.boost.org/doc/libs/1_60_0/doc/html/boost_asio/overview.html">Boost.asio</a> which is at the other end of the spectrum in terms of API and involves a cognitive leap to understand what is happening underneath (or you can just trust the library maintainers). The other alternative is <a href="https://curl.haxx.se/libcurl/c/">libcurl</a>; the &ldquo;easy curl&rdquo; layer is an abstraction of the <code>socket()</code> API, while the &ldquo;multi curl&rdquo; layer is an abstraction of the <code>pselect()</code> API that allows multiple sockets to be handled in a single thread.</p>

<p>I am writing a series of articles that start with a basic C++ client/server application and walk through building a C++ communication library. During this processes I will be using examples from <a href="http://codereview.stackexchange.com">codereview.stackexchange.com</a> to illustrate common mistakes and try to show how to write the code correctly (This will also be a learning exercise for me so please let me know if you spot a mistake).</p>

<p>Currently the plan is to write the following articles:</p>

<!-- Server listening for program sockets -->


<ul>
<li>Client/Server C</li>
<li>Client/Server C Read/Write</li>
<li>Client/Server C++ Wrapper</li>
<li>Mult-Threaded Server</li>
<li>Non-Blocking Socket</li>
<li>Co-Routines</li>
</ul>


<h2>Client/Server C++ Basic Version</h2>

<p>The minimum example of a working Client/Server application in C++:<br/>
The full working version is <a href="https://github.com/Loki-Astari/Examples/tree/master/Version1">here</a></p>

<p>```c   C Server <a href="https://github.com/Loki-Astari/Examples/blob/master/Version1/server.cpp">https://github.com/Loki-Astari/Examples/blob/master/Version1/server.cpp</a> source</p>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>define SERVER_BUFFER_SIZE      1024</h1>

<p>int main()
{</p>

<pre><code>int socketId = socket(PF_INET, SOCK_STREAM, 0);

struct sockaddr_in serverAddr;
bzero((char*)&amp;serverAddr, sizeof(serverAddr));
serverAddr.sin_family       = AF_INET;
serverAddr.sin_port         = htons(8080);
serverAddr.sin_addr.s_addr  = INADDR_ANY;
bind(socketId, (struct sockaddr *) &amp;serverAddr, sizeof(serverAddr));

listen(socketId, 5);

int                         finished    = 0;
while(!finished)
{
    struct  sockaddr_storage    serverStorage;
    socklen_t                   addr_size   = sizeof serverStorage;
    int newSocket = accept(socketId, (struct sockaddr*)&amp;serverStorage, &amp;addr_size);

    char        buffer[SERVER_BUFFER_SIZE];
    int         get = read(newSocket, buffer, SERVER_BUFFER_SIZE - 1);

    buffer[get] = '\0';
    fprintf(stdout, "%s\n", buffer);

    write(newSocket, "OK", 2);

    fprintf(stdout, "Message Complete\n");

    close(newSocket);
}
close(socketId);
</code></pre>

<p>}
```</p>

<p>```c C Client <a href="https://github.com/Loki-Astari/Examples/blob/master/Version1/client.cpp">https://github.com/Loki-Astari/Examples/blob/master/Version1/client.cpp</a> source</p>

<h1>include &lt;arpa/inet.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>define CLIENT_BUFFER_SIZE     1024</h1>

<p>int main(int argc, char* argv[])
{</p>

<pre><code>if (argc != 3)
{
    fprintf(stderr, "Usage: client &lt;host&gt; &lt;Message&gt;\n");
    exit(1);
}

int socketId = socket(PF_INET, SOCK_STREAM, 0);

struct sockaddr_in serverAddr;
socklen_t addrSize = sizeof(serverAddr);
bzero((char*)&amp;serverAddr, sizeof(serverAddr));
serverAddr.sin_family       = AF_INET;
serverAddr.sin_port         = htons(8080);
serverAddr.sin_addr.s_addr  = inet_addr(argv[1]);
connect(socketId, (struct sockaddr*)&amp;serverAddr, addrSize);

write(socketId, argv[2], strlen(argv[2]));

shutdown(socketId, SHUT_WR);

char    buffer[CLIENT_BUFFER_SIZE];
size_t  get = read(socketId, buffer, CLIENT_BUFFER_SIZE - 1);

buffer[get] = '\0';
fprintf(stdout, "%s %s\n", "Response from server", buffer);

close(socketId);
</code></pre>

<p>}
```</p>

<p>This version of the Client/Server actually works (a lot of the time) but obviously has a couple of major issues.</p>

<h2>Checking Error Codes</h2>

<p>If the calls to <code>socket()</code>, <code>bind()</code>, <code>listen()</code> or <code>connect()</code> fail then we have a catastrophic error any further actions will also fail. A few of the error codes generated by these functions can potentially be recovered from but most are programming error or permission failure as a result a human readable message with application termination is an acceptable solution (at this point).</p>

<p>Note: When these functions don&rsquo;t succeed they set the global variable <code>errno</code> which can be translated into a human readable string with <code>strerror()</code>. So the simplest solution is to generate an appropriate error message for the user and terminate the application.</p>

<p>```c Socket Validation</p>

<pre><code>int socketId = socket(PF_INET, SOCK_STREAM, 0);
if (socketId == -1)
{
    fprintf(stderr, "Failed: socket()\n%s\n", strerror());
    exit(1);
}
</code></pre>

<p>```</p>

<p>```c Bind Validation</p>

<pre><code>if (bind(socketId, (struct sockaddr *) &amp;serverAddr, sizeof(serverAddr)) == -1)
{
    fprintf(stderr, "Failed: bind()\n%s\n", strerror());
    close(socketId);    // Don't forget to close the socket.
    exit(1);
}
</code></pre>

<p>```</p>

<p>```c Listen Validation</p>

<pre><code>if (listen(socketId, 5) == -1)
{
    fprintf(stderr, "Failed: connect()\n%s\n", strerror());
    close(socketId);    // Don't forget to close the socket.
    exit(1);
}
</code></pre>

<p>```</p>

<p>```c Connect Validation</p>

<pre><code>if (connect(socketId, (struct sockaddr*)&amp;serverAddr, addrSize) == -1)
{
    fprintf(stderr, "Failed: connect()\n%s\n", strerror());
    close(socketId);    // Don't forget to close the socket.
    exit(1);
}
</code></pre>

<p>```</p>

<h1>Summary</h1>

<p>The basic socket programs are relatively trivial. But this version 1 has some obvious flaws the major one being checking error states (which a lot of beginners forget in their first version). The next article will look into some more details about read and write operations on the socket.</p>

<h1>Inspiration for Article</h1>

<ul>
<li>2012-Jul-09 <a href="http://codereview.stackexchange.com/q/13461/507">Two-way communication in TCP: server-client implementation</a></li>
<li>2012-Jul-23 <a href="http://codereview.stackexchange.com/q/13933/507">Stupidly simple TCP client/server</a></li>
<li>2013-May-28 <a href="http://codereview.stackexchange.com/q/26683/507">How is this for a “Hello World” of socket programming?</a></li>
<li>2013-Sep-06 <a href="http://codereview.stackexchange.com/q/30852/507">Extract location from HTTP socket</a></li>
<li>2014-Mar-10 <a href="http://codereview.stackexchange.com/q/43914/507">Client/server implementation in C (sending data/files)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Resizing]]></title>
    <link href="http://lokiastari.com/blog/2016/03/25/resizemaths/"/>
    <updated>2016-03-25T05:53:07-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/25/resizemaths</id>
    <content type="html"><![CDATA[<p>So I never really considered why the resize of vector used a constant expansion of 1.5 or 2 (in some popular implementations). That was until I did my previous article series <a href="/blog/2016/02/27/vector/">&ldquo;Vector&rdquo;</a> where I concentrated a lot on resource management and did a section on <a href="/blog/2016/03/12/vector-resize/">resizing the vector</a>. Originally in the code I tried to be clever, a mistake. I used a resize value of 1.62 (an approximation of <code>Phi</code>), because I vaguely remembered reading an article that this was the optimum resize factor. When I put this out for code review it was pointed out to me that this value was too large, the optimum value must be less than or equal to <code>Phi</code> (1.6180339887) and that exceeding this limit actually made things a lot worse.</p>

<p>So I had to know why&hellip;.</p>

<p>So the theory goes: You have a memory resource of size <code>B</code>. If you resize this resource by a constant factor <code>r</code> by re-allocating a new block then releasing the old block. Then if the value of <code>r</code> is smaller than or equal to <code>Phi</code> you will eventually be able to reuse memory that has previously been released; otherwise the new block of memory being allocated will always be larger than the previously released memory.</p>

<p>So I thought lets try that:<br/>
Test one <code>r &gt; Phi</code>:</p>

<pre><code>B=10
r=2.0

            Sum Memory      Memory      Memory Needed       Difference
             Released     Allocated     Next Iteration
Start            0            10              20                 20
Resize 1        10            20              40                 30
Resize 2        30            40              80                 50
Resize 3        70            80             160                 90
Resize 4       150           160             320                170
</code></pre>

<p>OK. That seems to be holding (at least in the short term). Lo lets try a smaller value.<br/>
Test two <code>r &lt; Phi</code>:</p>

<pre><code>B=10
r=1.5

            Sum Memory      Memory      Memory Needed       Difference
             Released     Allocated     Next Iteration
Start            0            10              15                 15
Resize 1        10            15              22                 12
Resize 2        25            22              33                  8
Resize 3        47            33              48                  1
Resize 4        80            48              72                 -8 // Reuse released memory next iteration
</code></pre>

<p>OK. That also seems to be holding. But can we show that holds for all values of B? Also this is a bit anecdotal can we actually show this relationship actually hold? Time to break out some maths (not math as my American cousins seem to insist on for the shortening of mathematics).</p>

<p>So the size <code>S</code> of any block after <code>n</code> resize operations will be:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ S   = Br^n \]
</code></pre>

<p></notextile></div></p></p>

<p>Thus the size of <code>Released Memory</code> can be expressed as:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ \sum_{k=0}^{n-1}\ Br^k \]
</code></pre>

<p></notextile></div></p></p>

<p>Also the size of the next block will be:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ Br^{n+1} \]
</code></pre>

<p></notextile></div></p></p>

<p>So if the amount of <code>Released Memory</code> >= the amount required for the next block, then we can reuse the <code>Released Memory</code>.</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ \sum_{k=0}^{n-1}\ Br^k &amp;gt;= Br^{n+1} \]

\[ B \sum_{k=0}^{n-1}\ r^k &amp;gt;= Br^{n+1} \]

\[ \sum_{k=0}^{n-1}\ r^k &amp;gt;= r^{n+1} \]

\[ {1-r^{(n-1)+1}\over1-r} &amp;gt;= r^{n+1} \]

\[ {1-r^n\over1-r} &amp;gt;= r^{n+1} \]

\[ 1-r^n &amp;gt;= r^{n+1} (1-r) \]

\[ 1-r^n &amp;gt;= r^{n+1} - r^{n+2} \]

\[ 1 + r^{n+2} - r^{n+1} - r^n &amp;gt;= 0 \]

\[ 1 + r^n (r^2 - r - 1) &amp;gt;= 0 \]
</code></pre>

<p></notextile></div></p></p>

<p>This is were my maths broke down and I had to plot some graphs (my old &ldquo;maths&rdquo; teacher would have been so proud).<br></p>

<p><img src="/images/Root4.png" width="400" height="200" title="&ldquo;n=4&rdquo;" >
<img src="/images/Root8.png" width="400" height="200" title="&ldquo;n=8&rdquo;" ></p>

<br><br>


<p>So after looking at the graphs (to undrestand the formula) then talking to some smart people.<br/>
They noticed that:
<p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ (r^2 - r - 1) root . when . r = \Phi \]
</code></pre>

<p></notextile></div></p></p>

<p>We find that the first root of the equation is 1. The second root of the equation depends on <code>n</code>, as <code>n</code> tends to <code>infinity</code> the other root tends towards <code>Phi</code>. From this we can infer the following:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[
    1 &amp;lt; r &amp;lt= \Phi
\]
</code></pre>

<p></notextile></div></p></p>

<p>Thus if <code>r</code> remains in the above range then the above theory holds.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - The Other Stuff]]></title>
    <link href="http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff/"/>
    <updated>2016-03-20T22:26:43-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff</id>
    <content type="html"><![CDATA[<p>So the C++ standard specifies a set of requirements for containers. Very few requirements are specified in terms of containers so adhering to these exactly is not required (unless you want to be considered for the standard). But they provide an insight into what can be done with them and if you support them will allow your container to be more easily used with some features of the language and standard library. I am not going to go over all of them here (that is left as an exercise for the reader), but I will go over the ones I would expect to see in a simple implementation (the kind you would see in a university project).</p>

<p>For details see the <a href="http://stackoverflow.com/a/4653479/14065">latest copy of the C++ standard</a>.</p>

<ul>
<li>23.2.1  General container requirements [container.requirements.general]</li>
<li>23.2.3  Sequence containers [sequence.reqmts]</li>
</ul>


<h4>Internal Types</h4>

<ul>
<li>value&#95;type</li>
<li>reference</li>
<li>const&#95;reference</li>
<li>iterator</li>
<li>const&#95;iterator</li>
<li>difference&#95;type</li>
<li>size&#95;type</li>
</ul>


<p>It is worth specifying the internal types defined here. As this allows you to abstract the implementation details of the container. This will allow you to change the implementation details without users having to change their implementation; as long as the changes still provide the same interface but the interface to reference/pointers/iterators are relatively trivial and well defined.</p>

<h4>Constructors</h4>

<p>In C++11 the <code>std::initializer_list&lt;T&gt;</code> was introduced. This allows a better list initialization syntax to be used with user defined types. Since this is usually defined in terms of the range based construction we should probably add both of these constructors.</p>

<ul>
<li>Vector(std::initializer&#95;list<T> const&amp; list)</li>
<li>Vector(I begin, I end)</li>
</ul>


<h4>Iterators</h4>

<ul>
<li>begin()</li>
<li>rbegin()</li>
<li>begin() const</li>
<li>rbegin() const</li>
<li>cbegin() const</li>
<li>crbegin() const</li>
<li>end()</li>
<li>rend()</li>
<li>end() const</li>
<li>cend() const</li>
<li>rend() const</li>
<li>crend() const</li>
</ul>


<p>The iterators are relatively easy to write. They also allow the container to be used with the new range based for that was added in C++14. So this becomes another easy add.</p>

<h4>Member Access</h4>

<ul>
<li>at(&lt;index&gt;)</li>
<li>at(&lt;index&gt;) const</li>
<li>operator&#91;&#93;(&lt;index&gt;)</li>
<li>operator&#91;&#93;(&lt;index&gt;) const</li>
<li>front()</li>
<li>back()</li>
<li>front() const</li>
<li>back() const</li>
</ul>


<p>Member access to a vector should be very efficient. As a result normally range checks are not performed on member access, i.e. the user is expected to make sure that the method preconditions have been met before calling the method. This results in very efficient access to the members of a <code>Vector</code>. This is not normally a problem because index ranges are normally checked as part of a loop range as long as these are validated against the size of the array it does not need to be validated again.</p>

<p>```cpp For Loop Vector Access</p>

<pre><code>Vector&lt;T&gt;   d = getData();
for(int loop = 0; loop &lt; d.size(); ++loop)
{
    std::cout &lt;&lt; d[loop];   // No need for antoher range
                            // check here as we know that loop is inside the
                            // bounds of the vector d.
}
</code></pre>

<p>```</p>

<p>There is also the <code>at()</code> method which does validate the index provided before accessing the element (throwing an exception if the index is out of range).</p>

<h4>Non-Mutating Member Functions</h4>

<ul>
<li>size() const</li>
<li>bool() const</li>
</ul>


<p>To allow us to check the preconditions on the element access methods we need some functions that check the state of the object. These are provided here.</p>

<h4>Mutating Member Functions</h4>

<ul>
<li>push&#95;back(&lt;object-ref&gt;)</li>
<li>push&#95;back(&lt;object-rvalue-ref&gt;)</li>
<li>emplace&#95;back(&lt;args&hellip;&gt;)</li>
<li>pop&#95;back()</li>
</ul>


<p>The following members are standard easy to implement methods of <code>std::vector</code> (O(1)) that I would expect to see in every implementation.</p>

<p>The other mutating member functions are less trivial as they require elements to be moved around. They are not that hard but you must put some thought into the most efficient techniques to move elements (i.e. move or copy) and make sure that capacity is not exceeded by multiple inserts. As a result I would expect to see these methods only on an as needed basis.</p>

<h4>Comparators</h4>

<ul>
<li>operator== const</li>
<li>operator!= const</li>
</ul>


<p>Easy comparison operators.
Optionally you can provide the other comparison operators.</p>

<h1>Final</h1>

<p><strong>No idea why Jackal is adding all the blank lines to my source</strong>
```cpp Vector</p>

<h1>include &lt;type_traits></h1>

<h1>include <memory></h1>

<h1>include <algorithm></h1>

<h1>include <stdexcept></h1>

<h1>include <iterator></h1>

<p>template<typename T>
class Vector
{</p>

<pre><code>public:
    using value_type        = T;
    using reference         = T&amp;;
    using const_reference   = T const&amp;;
    using pointer           = T*;
    using const_pointer     = T const*;
    using iterator          = T*;
    using const_iterator    = T const*;
    using riterator         = std::reverse_iterator&lt;iterator&gt;;
    using const_riterator   = std::reverse_iterator&lt;const_iterator&gt;;
    using difference_type   = std::ptrdiff_t;
    using size_type         = std::size_t;

private:
    size_type       capacity;
    size_type       length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    template&lt;typename I&gt;
    Vector(I begin, I end)
        : capacity(std::distance(begin, end))
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        for(auto loop = begin;loop != end; ++loop)
        {
            pushBackInternal(*loop);
        }
    }
    Vector(std::initializer_list&lt;T&gt; const&amp; list)
        : Vector(std::begin(list), std::end(list))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            clearElements&lt;T&gt;();

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        copyAssign&lt;T&gt;(copy);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }

    // Non-Mutating functions
    size_type           size() const                        {return length;}
    bool                empty() const                       {return length == 0;}

    // Validated element access
    reference           at(size_type index)                 {validateIndex(index);return buffer[index];}
    const_reference     at(size_type index) const           {validateIndex(index);return buffer[index];}

    // Non-Validated element access
    reference           operator[](size_type index)         {return buffer[index];}
    const_reference     operator[](size_type index) const   {return buffer[index];}
    reference           front()                             {return buffer[0];}
    const_reference     front() const                       {return buffer[0];}
    reference           back()                              {return buffer[length - 1];}
    const_reference     back() const                        {return buffer[length - 1];}

    // Iterators
    iterator            begin()                             {return buffer;}
    riterator           rbegin()                            {return riterator(end());}
    const_iterator      begin() const                       {return buffer;}
    const_riterator     rbegin() const                      {return const_riterator(end());}

    iterator            end()                               {return buffer + length;}
    riterator           rend()                              {return riterator(begin());}
    const_iterator      end() const                         {return buffer + length;}
    const_riterator     rend() const                        {return const_riterator(begin());}

    const_iterator      cbegin() const                      {return begin();}
    const_riterator     crbegin() const                     {return rbegin();}
    const_iterator      cend() const                        {return end();}
    const_riterator     crend() const                       {return rend();}

    // Comparison
    bool operator!=(Vector const&amp; rhs) const {return !(*this == rhs);}
    bool operator==(Vector const&amp; rhs) const
    {
        return  (size() == rhs.size())
            &amp;&amp;  std::equal(begin(), end(), rhs.begin());
    }

    // Mutating functions
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void push_back(T&amp;&amp; value)
    {
        resizeIfRequire();
        moveBackInternal(std::forward&lt;T&gt;(value));
    }
    template&lt;typename... Args&gt;
    void emplace_back(Args&amp;&amp;... args)
    {
        resizeIfRequire();
        emplaceBackInternal(std::forward&lt;T&gt;(args)...);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(size_type capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void validateIndex(size_type index) const
    {
        if (index &gt;= length)
        {
            throw std::out_of_range("Out of Range");
        }
    }

    void resizeIfRequire()
    {
        if (length == capacity)
        {
            size_type     newCapacity  = std::max(2.0, capacity * 1.5);
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(size_type newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }

    // Add new element to the end using placement new
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }
    template&lt;typename... Args&gt;
    void emplaceBackInternal(Args&amp;&amp;... args)
    {
        new (buffer + length) T(std::forward&lt;Args&gt;(args)...);
        ++length;
    }

    // Optimizations that use SFINAE to only instantiate one
    // of two versions of a function.
    //      simpleCopy()        Moves when no exceptions are guaranteed, otherwise copies.
    //      clearElements()     When no destructor remove loop.
    //      copyAssign()        Avoid resource allocation when no exceptions guaranteed.
    //                          ie. When copying integers reuse the buffer if we can
    //                          to avoid expensive resource allocation.

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }
    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }


    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be reused without using the destructor.
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                        &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // This function is only used if there is no chance of an exception being
        // thrown during destruction or copy construction of the type T.


        // Quick return for self assignment.
        if (this == &amp;copy)
        {
            return;
        }

        if (capacity &lt;= copy.length)
        {
            // If we have enough space to copy then reuse the space we currently
            // have to avoid the need to perform an expensive resource allocation.

            clearElements&lt;T&gt;();     // Potentially does nothing (see above)
                                    // But if required will call the destructor of
                                    // all elements.

            // buffer now ready to get a copy of the data.
            length = 0;
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                pushBackInternal(copy[loop]);
            }
        }
        else
        {
            // Fallback to copy and swap if we need to more space anyway
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                         &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
    }
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Simple Optimizations]]></title>
    <link href="http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations/"/>
    <updated>2016-03-19T15:06:40-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations</id>
    <content type="html"><![CDATA[<p>So now that we have used <code>std::is_nothrow_move_constructible</code> we can also look at a couple of other types available in the template utility library.</p>

<h1>Optimized Destruction</h1>

<p>Since we have to manually call the destructor on all objects in the container (because we are using placement new) we can look to see if we can optimize that. The type <code>std::is_trivially_destructible</code> detects if the type is <strong>Trivially</strong> destructible. This basically means that there will be no side effects from the destructor (See: Section 12.4 Paragraph 5 of the standard). For types we don&rsquo;t need to call the destructor of the object. For the <code>Vector</code> class this means we can eliminate the call to the destructor but more importantly the loop.</p>

<p>```cpp Destroying Elements</p>

<pre><code>    ~Vector()
    {
        // STUFF..

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            throw;
        }
    }
</code></pre>

<p>```</p>

<p>We can use the same SFINAE technique that we used in the previous article to remove the loops when the contained type is trivially destructible.</p>

<p>```</p>

<pre><code>    ~Vector()
    {
        // STUFF..
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            clearElements&lt;T&gt;();
            throw;
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be re-used without using the destructor.
    }
</code></pre>

<p>```</p>

<h1>Optimized Assignment Operator</h1>

<p>The final optimization is because resource allocation is expensive. So if we can avoid the resource allocation completely and just reuse the space we currently have.</p>

<p>```cpp Copy Assignment</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
</code></pre>

<p>```</p>

<p>The copy and swap idiom is perfect for providing the strong exception guarantee in the presence of exceptions. <strong>But</strong> if there are no exceptions during destruction or construction then we can potentially just reuse the available memory. So if we rewrote the assignment operator with the assumption that there were no exceptions it would look like the following (Note in the real code use SFINAE to do the optimization only when necessary).</p>

<p>```cpp Copy the easy way</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Check for self assignment
        // As we are doing work anyway.
        if (this == &amp;copy)
        {
            return *this;
        }

        // If the length of the `copy` object exceeds
        // the capacity of the current object then
        // we have to do resource management. It costs
        // nothing extra to use the copy and swap idiom
        if (copy.length &gt; capacity)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
            return *this;
        }

        // The optimization happens here.
        // We can reuse the buffer we already have.
        clearElements&lt;T&gt;();     // use clearElements() as it probably does very little.
        length = 0;

        // Now add the elements to this container as cheaply as possible.
        for(int loop = 0; loop &lt; copy.length; ++loop)
        {
            pushBackInternal(copy[loop]);
        }
        return *this;
    }
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-4"></a></h1>

<p>The final version</p>

<p>```cpp Vector Final Version</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    std::size_t     capacity;
    std::size_t     length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

    public:
        Vector(int capacity = 10)
            : capacity(capacity)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {}
        ~Vector()
        {
            // Make sure the buffer is deleted even with exceptions
            // This will be called to release the pointer at the end
            // of scope.
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

            clearElements&lt;T&gt;();
        }
        Vector(Vector const&amp; copy)
            : capacity(copy.length)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {
            try
            {
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    push_back(copy.buffer[loop]);
                }
            }
            catch(...)
            {
                std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
                clearElements&lt;T&gt;();

                // Make sure the exceptions continue propagating after
                // the cleanup has completed.
                throw;
            }
        }
        Vector&amp; operator=(Vector const&amp; copy)
        {
            copyAssign&lt;T&gt;(copy);
            return *this;
        }
        Vector(Vector&amp;&amp; move) noexcept
            : capacity(0)
            , length(0)
            , buffer(nullptr)
        {
            move.swap(*this);
        }
        Vector&amp; operator=(Vector&amp;&amp; move) noexcept
        {
            move.swap(*this);
            return *this;
        }
        void swap(Vector&amp; other) noexcept
        {
            using std::swap;
            swap(capacity,      other.capacity);
            swap(length,        other.length);
            swap(buffer,        other.buffer);
        }
        void push_back(T const&amp; value)
        {
            resizeIfRequire();
            pushBackInternal(value);
        }
        void pop_back()
        {
            --length;
            buffer[length].~T();
        }
        void reserve(std::size_t capacityUpperBound)
        {
            if (capacityUpperBound &gt; capacity)
            {
                reserveCapacity(capacityUpperBound);
            }
        }
    private:
        void resizeIfRequire()
        {
            if (length == capacity)
            {
                std::size_t     newCapacity  = std::max(2.0, capacity * 1.62);
                reserveCapacity(newCapacity);
            }
        }
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            simpleCopy&lt;T&gt;(tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
        clearElements()
        {
            // Call the destructor on all the members in reverse order
            for(int loop = 0; loop &lt; length; ++loop)
            {
                // Note we destroy the elements in reverse order.
                buffer[length - 1 - loop].~T();
            }
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
        clearElements()
        {
            // Trivially destructible objects can be reused without using the destructor.
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            if (this == &amp;copy)
            {
                return;
            }

            if (capacity &lt;= copy.length)
            {
                clearElements&lt;T&gt;();
                length = 0;
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    pushBackInternal(copy[loop]);
                }
            }
            else
            {
                // Copy and Swap idiom
                Vector&lt;T&gt;  tmp(copy);
                tmp.swap(*this);
            }
        }
        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
};
</code></pre>

<p>```</p>

<h1>Summary</h1>
]]></content>
  </entry>
  
</feed>
