<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Loki Astari]]></title>
  <link href="http://lokiastari.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://lokiastari.com/"/>
  <updated>2016-03-31T21:51:13-07:00</updated>
  <id>http://lokiastari.com/</id>
  <author>
    <name><![CDATA[Loki Astari]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Memory Resizing]]></title>
    <link href="http://lokiastari.com/blog/2016/03/25/resizemaths/"/>
    <updated>2016-03-25T05:53:07-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/25/resizemaths</id>
    <content type="html"><![CDATA[<p>So I never really considered why the resize of vector used a constant expansion of 1.5 or 2 (in some popular implementations). That was until I did my previous article series <a href="/blog/2016/02/27/vector/">&ldquo;Vector&rdquo;</a> where I concentrated a lot on resource management and did a section on <a href="/blog/2016/03/12/vector-resize/">resizing the vector</a>. I tried to be clever, a mistake. I used a resize value of 1.62 (an approximation of <code>Phi</code>), because I vaguely remembered reading an article that this was the optimum resize factor. When I put this out for code review it was pointed out to me that this value was too large, the optimum value must be less than or equal to <code>Phi</code> (1.6180339887) and that exceeding this limit actually made things a lot worse.</p>

<p>So I had to know why&hellip;.</p>

<p>So the theory goes: You have a memory resource of size <code>B</code>. If you resize this resource by a constant factor <code>r</code> by re-allocating a new block then releasing the old block. Then if the value of <code>r</code> is smaller than or equal to <code>Phi</code> you will eventually be able to reuse memory that has previously been released; otherwise the new block of memory being allocated will always be larger than the previously released memory.</p>

<p>So I thought lets try that:<br/>
Test one <code>r &gt; Phi</code>:</p>

<pre><code>B=10
r=2.0

            Sum Memory      Memory      Memory Needed       Difference
             Released     Allocated     Next Iteration
Start            0            10              20                 20
Resize 1        10            20              40                 30
Resize 2        30            40              80                 50
Resize 3        70            80             160                 90
Resize 4       150           160             320                170
</code></pre>

<p>OK. That seems to be holding (at least in the short term). Lo lets try a smaller value.<br/>
Test two <code>r &lt; Phi</code>:</p>

<pre><code>B=10
r=1.5

            Sum Memory      Memory      Memory Needed       Difference
             Released     Allocated     Next Iteration
Start            0            10              15                 15
Resize 1        10            15              22                 12
Resize 2        25            22              33                  8
Resize 3        47            33              48                  1
Resize 4        80            48              72                 -8 // Reuse released memory next iteration
</code></pre>

<p>OK. That also seems to be holding. But can we show that holds for all values of B? Also this is a bit anecdotal can we actually show this relationship actually hold? Time to break out some maths (not math as my American cousins seem to insist on for the shortening of mathematics).</p>

<p>So the size <code>S</code> of any block after <code>n</code> resize operations will be:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ S   = Br^n \]
</code></pre>

<p></notextile></div></p></p>

<p>Thus the size of <code>Released Memory</code> can be expressed as:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ \sum_{k=0}^{n-1}\ Br^k \]
</code></pre>

<p></notextile></div></p></p>

<p>Also the size of the next block will be:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ Br^{n+1} \]
</code></pre>

<p></notextile></div></p></p>

<p>So if the amount of <code>Released Memory</code> >= the amount required for the next block, then we can reuse the <code>Released Memory</code>.</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ \sum_{k=0}^{n-1}\ Br^k &amp;gt;= Br^{n+1} \]

\[ B \sum_{k=0}^{n-1}\ r^k &amp;gt;= Br^{n+1} \]

\[ \sum_{k=0}^{n-1}\ r^k &amp;gt;= r^{n+1} \]

\[ {1-r^{(n-1)+1}\over1-r} &amp;gt;= r^{n+1} \]

\[ {1-r^n\over1-r} &amp;gt;= r^{n+1} \]

\[ 1-r^n &amp;gt;= r^{n+1} (1-r) \]

\[ 1-r^n &amp;gt;= r^{n+1} - r^{n+2} \]

\[ 1 + r^{n+2} - r^{n+1} - r^n &amp;gt;= 0 \]

\[ 1 + r^n (r^2 - r - 1) &amp;gt;= 0 \]
</code></pre>

<p></notextile></div></p></p>

<p>This is were my maths broke down and I had to plot some graphs (my old &ldquo;maths&rdquo; teacher would have been so proud).<br></p>

<p><img src="/images/Root4.png" width="400" height="200" title="&ldquo;n=4&rdquo;" >
<img src="/images/Root8.png" width="400" height="200" title="&ldquo;n=8&rdquo;" ></p>

<br><br>


<p>So after looking at the graphs (to undrestand the formula) then talking to some smart people.<br/>
They noticed that:
<p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[ (r^2 - r - 1) root . when . r = \Phi \]
</code></pre>

<p></notextile></div></p></p>

<p>We find that the first root of the equation is 1. The second root of the equation depends on <code>n</code>, as <code>n</code> tends to <code>infinity</code> the other root tends towards <code>Phi</code>. From this we can infer the following:</p>

<p><p><div class='bogus-wrapper'><notextile></p>

<pre><code>\[
    1 &amp;lt; r &amp;lt= \Phi
\]
</code></pre>

<p></notextile></div></p></p>

<p>Thus if <code>r</code> remains in the above range then the above theory holds.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - The Other Stuff]]></title>
    <link href="http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff/"/>
    <updated>2016-03-20T22:26:43-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff</id>
    <content type="html"><![CDATA[<p>So the C++ standard specifies a set of requirements for containers. Very few requirements are specified in terms of containers so adhering to these exactly is not required (unless you want to be considered for the standard). But they provide an insight into what can be done with them and if you support them will allow your container to be more easily used with some features of the language and standard library. I am not going to go over all of them here (that is left as an exercise for the reader), but I will go over the ones I would expect to see in a simple implementation (the kind you would see in a university project).</p>

<p>For details see the <a href="http://stackoverflow.com/a/4653479/14065">latest copy of the C++ standard</a>.</p>

<ul>
<li>23.2.1  General container requirements [container.requirements.general]</li>
<li>23.2.3  Sequence containers [sequence.reqmts]</li>
</ul>


<h4>Internal Types</h4>

<ul>
<li>value&#95;type</li>
<li>reference</li>
<li>const&#95;reference</li>
<li>iterator</li>
<li>const&#95;iterator</li>
<li>difference&#95;type</li>
<li>size&#95;type</li>
</ul>


<p>It is worth specifying the internal types defined here. As this allows you to abstract the implementation details of the container. This will allow you to change the implementation details without users having to change their implementation; as long as the changes still provide the same interface but the interface to reference/pointers/iterators are relatively trivial and well defined.</p>

<h4>Constructors</h4>

<p>In C++11 the <code>std::initializer_list&lt;T&gt;</code> was introduced. This allows a better list initialization syntax to be used with user defined types. Since this is usually defined in terms of the range based construction we should probably add both of these constructors.</p>

<ul>
<li>Vector(std::initializer&#95;list<T> const&amp; list)</li>
<li>Vector(I begin, I end)</li>
</ul>


<h4>Iterators</h4>

<ul>
<li>begin()</li>
<li>rbegin()</li>
<li>begin() const</li>
<li>rbegin() const</li>
<li>cbegin() const</li>
<li>crbegin() const</li>
<li>end()</li>
<li>rend()</li>
<li>end() const</li>
<li>cend() const</li>
<li>rend() const</li>
<li>crend() const</li>
</ul>


<p>The iterators are relatively easy to write. They also allow the container to be used with the new range based for that was added in C++14. So this becomes another easy add.</p>

<h4>Member Access</h4>

<ul>
<li>at(&lt;index&gt;)</li>
<li>at(&lt;index&gt;) const</li>
<li>operator&#91;&#93;(&lt;index&gt;)</li>
<li>operator&#91;&#93;(&lt;index&gt;) const</li>
<li>front()</li>
<li>back()</li>
<li>front() const</li>
<li>back() const</li>
</ul>


<p>Member access to a vector should be very efficient. As a result normally range checks are not performed on member access, i.e. the user is expected to make sure that the method pre-conditions have been met before calling the method. This results in very efficient access to the members of a <code>Vector</code>. This is not normally a problem because index ranges are normally checked as part of a loop range as long as these are validated against the size of the array it does not need to be validated again.</p>

<p>```cpp For Loop Vector Access</p>

<pre><code>Vector&lt;T&gt;   d = getData();
for(int loop = 0; loop &lt; d.size(); ++loop)
{
    std::cout &lt;&lt; d[loop];   // No need for antoher range
                            // check here as we know that loop is inside the
                            // bounds of the vector d.
}
</code></pre>

<p>```</p>

<p>There is also the <code>at()</code> method which does validate the index provided before accessing the element (throwing an exception if the index is out of range).</p>

<h4>Non-Mutating Member Functions</h4>

<ul>
<li>size() const</li>
<li>bool() const</li>
</ul>


<p>To allow us to check the pre-conditions on the element accesses methods we need a couple of functions that check the state of the object. These are provided here.</p>

<h4>Mutating Member Functions</h4>

<ul>
<li>push&#95;back(&lt;object-ref&gt;)</li>
<li>push&#95;back(&lt;object-rvalue-ref&gt;)</li>
<li>emplace&#95;back(&lt;args&hellip;&gt;)</li>
<li>pop&#95;back()</li>
</ul>


<p>The following members are standard easy to implement methods of <code>std::vector</code> (O(1)) that I would expect to see in every implementation.</p>

<p>The other mutating member functions are less trivial as they require elements to be moved around. They are not that hard but you must put some though into the most efficient techniques to move elements (i.e. move or copy) and make sure that capacity is not exceeded by multiple inserts. As a result I would expect to see these methods only on a as need basis.</p>

<h4>Comparators</h4>

<ul>
<li>operator== const</li>
<li>operator!= const</li>
</ul>


<p>Easy comparison operators.<br/>
Optionally you can provide the other comparison operators.</p>

<h1>Final</h1>

<p><strong>No idea why Jackal is adding all the blank lines to my source</strong>
```cpp Vector</p>

<h1>include &lt;type_traits></h1>

<h1>include <memory></h1>

<h1>include <algorithm></h1>

<h1>include <stdexcept></h1>

<h1>include <iterator></h1>

<p>template<typename T>
class Vector
{</p>

<pre><code>public:
    using value_type        = T;
    using reference         = T&amp;;
    using const_reference   = T const&amp;;
    using pointer           = T*;
    using const_pointer     = T const*;
    using iterator          = T*;
    using const_iterator    = T const*;
    using riterator         = std::reverse_iterator&lt;iterator&gt;;
    using const_riterator   = std::reverse_iterator&lt;const_iterator&gt;;
    using difference_type   = std::ptrdiff_t;
    using size_type         = std::size_t;

private:
    size_type       capacity;
    size_type       length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    template&lt;typename I&gt;
    Vector(I begin, I end)
        : capacity(std::distance(begin, end))
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        for(auto loop = begin;loop != end; ++loop)
        {
            pushBackInternal(*loop);
        }
    }
    Vector(std::initializer_list&lt;T&gt; const&amp; list)
        : Vector(std::begin(list), std::end(list))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            clearElements&lt;T&gt;();

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        copyAssign&lt;T&gt;(copy);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }

    // Non-Mutating functions
    size_type           size() const                        {return length;}
    bool                empty() const                       {return length == 0;}

    // Validated element access
    reference           at(size_type index)                 {validateIndex(index);return buffer[index];}
    const_reference     at(size_type index) const           {validateIndex(index);return buffer[index];}

    // Non-Validated element access
    reference           operator[](size_type index)         {return buffer[index];}
    const_reference     operator[](size_type index) const   {return buffer[index];}
    reference           front()                             {return buffer[0];}
    const_reference     front() const                       {return buffer[0];}
    reference           back()                              {return buffer[length - 1];}
    const_reference     back() const                        {return buffer[length - 1];}

    // Iterators
    iterator            begin()                             {return buffer;}
    riterator           rbegin()                            {return riterator(end());}
    const_iterator      begin() const                       {return buffer;}
    const_riterator     rbegin() const                      {return const_riterator(end());}

    iterator            end()                               {return buffer + length;}
    riterator           rend()                              {return riterator(begin());}
    const_iterator      end() const                         {return buffer + length;}
    const_riterator     rend() const                        {return const_riterator(begin());}

    const_iterator      cbegin() const                      {return begin();}
    const_riterator     crbegin() const                     {return rbegin();}
    const_iterator      cend() const                        {return end();}
    const_riterator     crend() const                       {return rend();}

    // Comparison
    bool operator!=(Vector const&amp; rhs) const {return !(*this == rhs);}
    bool operator==(Vector const&amp; rhs) const
    {
        return  (size() == rhs.size())
            &amp;&amp;  std::equal(begin(), end(), rhs.begin());
    }

    // Mutating functions
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void push_back(T&amp;&amp; value)
    {
        resizeIfRequire();
        moveBackInternal(std::forward&lt;T&gt;(value));
    }
    template&lt;typename... Args&gt;
    void emplace_back(Args&amp;&amp;... args)
    {
        resizeIfRequire();
        emplaceBackInternal(std::forward&lt;T&gt;(args)...);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(size_type capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void validateIndex(size_type index) const
    {
        if (index &gt;= length)
        {
            throw std::out_of_range("Out of Range");
        }
    }

    void resizeIfRequire()
    {
        if (length == capacity)
        {
            size_type     newCapacity  = std::max(2.0, capacity * 1.5);
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(size_type newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }

    // Add new element to the end using placement new
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }
    template&lt;typename... Args&gt;
    void emplaceBackInternal(Args&amp;&amp;... args)
    {
        new (buffer + length) T(std::forward&lt;Args&gt;(args)...);
        ++length;
    }

    // Optimizations that use SFINAE to onlt instanciate one
    // of two versions of a function.
    //      simpleCopy()        Moves when no exceptions are guranteed, otherwise copies.
    //      clearElements()     When no destructor remove loop.
    //      copyAssign()        Avoid resource allocation when no exceptions guranteed.
    //                          ie. When copying integers re-use the buffer if we can
    //                          to avoid expensive resource allocation.

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }
    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }


    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be re-used without using the destructor.
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                        &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // This function is only used if there is no chance of an exception being
        // throw during destruction or copy construction of the type T.


        // Quick return for self assignment.
        if (this == &amp;copy)
        {
            return;
        }

        if (capacity &lt;= copy.length)
        {
            // If we have enough space to copy then re-use the sapce we currently
            // have to avoid the need to perform an expensive resource allocation.

            clearElements&lt;T&gt;();     // Potentially does nothing (see above)
                                    // But if required will call the destructor of
                                    // all elements.

            // buffer now ready to get a copy of the data.
            length = 0;
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                pushBackInternal(copy[loop]);
            }
        }
        else
        {
            // Fallback to copy and swap if we need to more space anyway
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                         &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
    }
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Simple Optimizations]]></title>
    <link href="http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations/"/>
    <updated>2016-03-19T15:06:40-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations</id>
    <content type="html"><![CDATA[<p>So now that we have used <code>std::is_nothrow_move_constructible</code> we can also look at a couple of other types available in the template utility library.</p>

<h1>Optimized Destruction</h1>

<p>Since we have to manually call the destructor on all objects in the container (because we are using placement new) we can look to see if we can optimize that. The type <code>std::is_trivially_destructible</code> detects if the type is <strong>Trivially</strong> destructible. This basically means that there will be no side affects from the destructor (See: Section 12.4 Paragraph 5 of the standard). For types we don&rsquo;t need to call the destructor of the object. For the <code>Vector</code> class this means we can eliminate the call to the destructor but more importantly the loop.</p>

<p>```cpp Destroying Elements</p>

<pre><code>    ~Vector()
    {
        // STUFF..

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            throw;
        }
    }
</code></pre>

<p>```</p>

<p>We can use the same SFINAE technique that we used in the previous article to remove the loops when the contained type is trivially destructible.</p>

<p>```</p>

<pre><code>    ~Vector()
    {
        // STUFF..
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            clearElements&lt;T&gt;();
            throw;
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be re-used without using the destructor.
    }
</code></pre>

<p>```</p>

<h1>Optimized Assignment Operator</h1>

<p>The final optimization is because resource allocation is expensive. So if we can avoid the resource allocation completely and just re-use the space we currently have.</p>

<p>```cpp Copy Assignment</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
</code></pre>

<p>```</p>

<p>The copy and swap idiom is perfect for providing the strong exception guarantee in the presence of exceptions. <strong>But</strong> if there are no exceptions during destruction or construction then we can potentially just re-use the available memory. So if we re-wrote the assignment operator with the assumption that there were no exceptions it would look like the following (Note in the real code use SFINAE to do the optimization only when necessary).</p>

<p>```cpp Copy the easy way</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Check for self assignment
        // As we are doing work anyway.
        if (this == &amp;copy)
        {
            return *this;
        }

        // If the length of the `copy` object exceeds
        // the capacity of the current object then
        // we have to do resource management. It costs
        // nothing extra to use the copy and swap idiom
        if (copy.length &gt; capacity)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
            return *this;
        }

        // The optimization happens here.
        // We can reuse the buffer we already have.
        clearElements&lt;T&gt;();     // use cearElements() as it probably does very little.
        length = 0;

        // Now add the elements to this container as cheaply as possible.
        for(int loop = 0; loop &lt; copy.length; ++loop)
        {
            pushBackInternal(copy[loop]);
        }
        return *this;
    }
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-4"></a></h1>

<p>The final version</p>

<p>```cpp Vector Final Version</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    std::size_t     capacity;
    std::size_t     length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

    public:
        Vector(int capacity = 10)
            : capacity(capacity)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {}
        ~Vector()
        {
            // Make sure the buffer is deleted even with exceptions
            // This will be called to release the pointer at the end
            // of scope.
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

            clearElements&lt;T&gt;();
        }
        Vector(Vector const&amp; copy)
            : capacity(copy.length)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {
            try
            {
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    push_back(copy.buffer[loop]);
                }
            }
            catch(...)
            {
                std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
                clearElements&lt;T&gt;();

                // Make sure the exceptions continue propagating after
                // the cleanup has completed.
                throw;
            }
        }
        Vector&amp; operator=(Vector const&amp; copy)
        {
            copyAssign&lt;T&gt;(copy);
            return *this;
        }
        Vector(Vector&amp;&amp; move) noexcept
            : capacity(0)
            , length(0)
            , buffer(nullptr)
        {
            move.swap(*this);
        }
        Vector&amp; operator=(Vector&amp;&amp; move) noexcept
        {
            move.swap(*this);
            return *this;
        }
        void swap(Vector&amp; other) noexcept
        {
            using std::swap;
            swap(capacity,      other.capacity);
            swap(length,        other.length);
            swap(buffer,        other.buffer);
        }
        void push_back(T const&amp; value)
        {
            resizeIfRequire();
            pushBackInternal(value);
        }
        void pop_back()
        {
            --length;
            buffer[length].~T();
        }
        void reserve(std::size_t capacityUpperBound)
        {
            if (capacityUpperBound &gt; capacity)
            {
                reserveCapacity(capacityUpperBound);
            }
        }
    private:
        void resizeIfRequire()
        {
            if (length == capacity)
            {
                std::size_t     newCapacity  = std::max(2.0, capacity * 1.62);
                reserveCapacity(newCapacity);
            }
        }
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            simpleCopy&lt;T&gt;(tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
        clearElements()
        {
            // Call the destructor on all the members in reverse order
            for(int loop = 0; loop &lt; length; ++loop)
            {
                // Note we destroy the elements in reverse order.
                buffer[length - 1 - loop].~T();
            }
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
        clearElements()
        {
            // Trivially destructible objects can be re-used without using the destructor.
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            if (this == &amp;copy)
            {
                return;
            }

            if (capacity &lt;= copy.length)
            {
                clearElements&lt;T&gt;();
                length = 0;
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    pushBackInternal(copy[loop]);
                }
            }
            else
            {
                // Copy and Swap idiom
                Vector&lt;T&gt;  tmp(copy);
                tmp.swap(*this);
            }
        }
        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
};
</code></pre>

<p>```</p>

<h1>Summary</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Resize]]></title>
    <link href="http://lokiastari.com/blog/2016/03/12/vector-resize/"/>
    <updated>2016-03-12T04:53:07-08:00</updated>
    <id>http://lokiastari.com/blog/2016/03/12/vector-resize</id>
    <content type="html"><![CDATA[<p>Because resizing a vector is expensive; the <code>std::vector</code> class uses exponential growth to minimize the number of times that the vector is resized. A technique we copied in this version. But every now and then you still need to do resize the internal buffer.</p>

<p>In the <a href="#VectorVersion-1">current version</a>, resizing the vector requires a new buffer be allocated and all the members copied into it. Basically we are using the copy and swap mechanism to provide the strong exception guarantee (If an exception is thrown all resources are cleaned up and the object remains unchanged).
```cpp Vector Resize with Copy</p>

<pre><code>    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T const&amp; v){tmpBuffer.pushBackInternal(v);}
                     );

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>```</p>

<h1>Resize With Move Construction</h1>

<p>Thus resizing a <code>Vector</code> can be a very expensive operation because of all the copying that can happen.</p>

<p>Using the move constructor rather than copy constructor during a resize operation could potentially be much more efficient. But the move constructor mutates the original object and thus if there is a problem we need to undo the mutations to maintain the strong exception guarantee.</p>

<p>The first attempt at this is:
```cpp Vector Resize with Move With Exceptions</p>

<pre><code>    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        try
        {
            std::for_each(buffer, buffer + length,
                          [&amp;tmpBuffer](T&amp; v){tmpBuffer.moveBackInternal(std::move(v));}
                         );
        }
        catch(...)
        {
            // If an exception is throw you need to move the objects back
            // from the temporary buffer back to this object.
            for(int loop=0; loop &lt; tmpBuffer.length; ++loop)
            {
                // The problem is here:
                // If the initial move can throw,
                // then trying to move any of the objects back can also throw.
                // which would leave the object in an inconsistent state.
                buffer[loop] = std::move(tmpBuffer[loop]);
            }

            // Then remember to rethrow the exception after we have fixed the state.
            throw;
        }

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>```</p>

<h1>Resize With NoThrow Move Construction</h1>

<p>As the above code shows; if the type <code>T</code> can throw during it&rsquo;s move constructor then you can&rsquo;t guarantee that the object gets returned to the original state (as moving the already moved elements back may cause another exception). So we can not use the move constructor to resize the vector if the type <code>T</code> can throw during move construction.</p>

<p>But not all types throw when being moved. In fact it is recommended that move constructors never throw. If we can guarantee that the move constructor does not throw then we can simplify the above code considerably and still provide the strong exception guarantee.
```cpp Vector Resize with Move</p>

<pre><code>    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T&amp; v){tmpBuffer.moveBackInternal(std::move(v));}
                     );

        tmpBuffer.swap(*this);
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }
</code></pre>

<p>```</p>

<h1>Resize Template Specialization</h1>

<p>So now we have to write the code that decides at compile time which version we should use. The simplest way to do this is to use template specialization of a class using the standard class <code>std::is_nothrow_move_constructible&lt;T&gt;</code> to help deferentiate types that have a none throwing move constructor. This is simple enough:
```cpp Template class Specialization</p>

<pre><code>template&lt;typename T, bool = std::is_nothrow_move_constructible&lt;T&gt;::value&gt;
struct SimpleCopy
{
    // Define two different versions of this class.
    // The object is to copy all the elements from src to dst Vector
    // using pushBackInternal or moveBackInternal
    //
    // SimpleCopy&lt;T, false&gt;:        Defines a version that use pushBackInternal (copy constructor)
    //                              This is always safe to use.
    // SimpleCopy&lt;T, true&gt;:         Defines a version that uses moveBackInternal (move constructor)
    //                              Safe when move construction does not throw.
    //
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const;
};
template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        // We are using private methods for effeciency.
        // So these classes need to be friends.
        friend struct SimpleCopy&lt;T, true&gt;;
        friend struct SimpleCopy&lt;T, false&gt;;

        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            // Create the copier object base on the type T.
            // Note: The second parameter is automatically generated based
            //       on if the type T is move constructable with no exception.
            SimpleCopy&lt;T&gt;   copier;
            copier(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }
}
// Define the two different types of copier
template&lt;typename T&gt;
struct SimpleCopy&lt;T, false&gt; // false: does not have nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }
};
template&lt;typename T&gt;
struct SimpleCopy&lt;T, true&gt; // true: has a nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }
};
</code></pre>

<p>```</p>

<h1>Resize With NoThrow SFINAE</h1>

<p>The above technique has a couple of issues.</p>

<p>The type <code>SimpleClass</code> is publicly available and is a friend of <code>Vector&lt;T&gt;</code>. This makes it suseptable to accidently being used (even if not explicitly documented). Unfortunately it can&rsquo;t be included as a member class and also be specialized.</p>

<p>Additionally it looks awful!!</p>

<p>But we can also use <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> and method overloading.</p>

<p>SFINAE allows us to define several versions of method with exactly the same arguments, as long as only one of them is valid at compile time. So in the example below we define two versions of the method <code>SimpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)</code> but then use <code>std::enable_if</code> to make sure only one version of the function id valid at compile time.</p>

<p>```cpp SFINAE method overload</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            SimpleCopy&lt;T&gt;(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }

        template&lt;typename X&gt;
        // Note: this defines the return type of the function.
        //       But only one has a valid member `type` thus only
        //       one of the following funcionts is actually valid.
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                         );
        }
}
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-3"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = std::max(2.0, capacity * 1.62);
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of the resiing the internal buffer. We have covered a couple of techniques on the way</p>

<ul>
<li>Move Constructor Concepts</li>
<li>Template Class Specialization</li>
<li>SFINAE</li>
<li>std::is_nothrow_move_constructible&lt;&gt;</li>
<li>std::enable_if&lt;&gt;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Resource Management Copy Swap]]></title>
    <link href="http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment/"/>
    <updated>2016-02-29T12:29:20-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment</id>
    <content type="html"><![CDATA[<p>In the previous article I went over basic allocation for a <code>Vector</code> like class. In this article I want to put some detail around the copy assignment operator and re-sizing the underlying <code>Vector</code>. Unlike the other methods previously discussed these methods have to deal with both construction and destruction of elements and the potential of exceptions interrupting the processes. The goal is to provide an exception safe methods that provides the strong exception guarantee for the object and do not leak resources.</p>

<h1>Copy Assignment</h1>

<h2>First Try</h2>

<p>This is a very common first attempt at a copy constructor.<br/>
It simply calls the destructor on all elements currently in the object. Then uses the existing <code>push_back()</code> method to copy member elements from the source object, thus allowing the object to automatically re-size if required.</p>

<p>```cpp Copy Assignment (Try 1)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // First we have to destroy all the current elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Destroy in reverse order
        buffer[length - 1 - loop].~T();
    }
    // Now the buffer is empty so reset size to zero.
    length = 0;

    // Now copy all the elements from the source into this object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Strong Exception Guarantee</h2>

<p>The obvious problems about efficiency when a resize is required is a minor issue here. The real problem is that this does not provide the strong exception guarantee. If any of the constructors/destructor throw then the object will be left in an inconsistent state, with no way to restore the original state. The strong exception guarantee basically means that the operation works or does not change the state of the object. The easiest technique to achieve this we must create the copy into a new temporary buffer that can be thrown away if things go wrong (leaving the current object untouched). If the copy succeeds then we use it and can throw away the original data.</p>

<p>```cpp Copy Assignment (Try 2)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy of the src object.
    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }

    // Part-2 Swap the state
    // We have successfully created the new version of this object
    // So swap the temporary and object states.
    std::swap(tmpCap,    capacity);
    std::swap(tmpSize,   length);
    std::swap(tmpBuffer, buffer);

    // Part-3 Destroy the old state.
    // Now we have to delete the old state.
    // If this fails it does not matter the state of the object is consistent
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Copy and Swap</h2>

<p>This second attempt is a better attempt. But it still leaks if an exception is throw. But before we add exception handling, let us take a closer look at the three sections of the assignment operator.</p>

<p>Part-1 looks exactly like the copy constructor of Vector.</p>

<p>```cpp Copy Assignment Part 1</p>

<pre><code>    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        // This looks exactly like push_back()
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }
</code></pre>

<p>```</p>

<p>Part-3 looks exactly like destructor of Vector.
```cpp Copy Assignment Part 3</p>

<pre><code>    // Now we have to delete the old state.
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
</code></pre>

<p>```</p>

<p>Using these two observations we have a re-write of the copy assignment operator.</p>

<p>```cpp Copy Assignment (Try 3)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy
    Vector  tmp(copy);

    // Part-2 Swap the state
    std::swap(tmp.capacity, capacity);
    std::swap(tmp.length,   length);
    std::swap(tmp.buffer,   buffer);

    return *this;
    // Part-3 Destructor called at end of scope.
    // No actual code required here.
}
</code></pre>

<p>};
```</p>

<h2><a href="http://stackoverflow.com/q/3279543/14065">Copy And Swap Idiom</a></h2>

<p>The copy and swap idiom is about dealing with replacing an object state from another object. It is very commonly used in the copy assignment operator but has application whenever state is being changed and the <a href="https://en.wikipedia.org/wiki/Exception_safety">strong exception guarantee</a> is required.</p>

<p>The above code works perfectly. But in Part-2 the swap looks like a normal swap operation so lets use that rather than doing it manually. Also self assignment now works without the need for a test (because we are copying into a temporary). So we can remove the check for self assignment. Yes this does make the performance for self assignment worse, but it make the normal operation even more efficient. Since the occurrences of self assignment are extremely rare I would not prematurely optimize for them and make the most common case the best optimized. So one final re-factor of the copy constructor leaves us with this.</p>

<p>```cpp Copy Assignment (Try 4)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    Vector  tmp(copy);
    tmp.swap(*this);
    return *this;
}
void swap(Vector&amp; other) noexcept
{
    std::swap(other.capacity, capacity);
    std::swap(other.length,   length);
    std::swap(other.buffer,   buffer);
}
</code></pre>

<p>};
```</p>

<h1>Resizing Underling buffer</h1>

<p>When pushing data into the array we need to verify that capacity has not been exceeded. If it has then we to allocate more capacity then copy the current content into the new buffer and destroy the old buffer, after calling the destructor on all elements.</p>

<h2>Using Copy and Swap</h2>

<p>This operation is exceedingly similar to the description we did with the copy assignment operator. As a result the best solution looks very similar and used the Copy and Swap Idiom.</p>

<p>```cpp Vector Reallocating Buffer
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    
void resizeIfRequire()
{
    if (length == capacity)
    {
        // Create a temporary object with a larger capacity.
        std::size_t     newCapacity  = std::max(2.0, capacity * 1.62);
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        // Copy the state of this object into the new object.
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; item){tmpBuffer.push_back(item);});

        // All the work has been successfully done. So swap
        // the state of the temporary and the current object.
        tmpBuffer.swap(*this);

        // The temporary object goes out of scope here and
        // tidies up the state that is no longer needed.
    }
}
</code></pre>

<p>};
```</p>

<h1>Final Version <a id="VectorVersion-2"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = std::max(2.0, capacity * 1.62);
            reserveCapacity(newCapacity);
        }
    }
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; v){tmpBuffer.pushBackInternal(v);});

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of the Copy and Swap Idiom and show how it is used in the Copy Assignment Operator and the resize operation.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Copy and Swap Idiom</li>
<li>Exception Gurantees</li>
</ul>

]]></content>
  </entry>
  
</feed>
