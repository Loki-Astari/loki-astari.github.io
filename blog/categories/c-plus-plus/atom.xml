<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | Loki Astari]]></title>
  <link href="http://lokiastari.com/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://lokiastari.com/"/>
  <updated>2016-03-01T11:22:39-08:00</updated>
  <id>http://lokiastari.com/</id>
  <author>
    <name><![CDATA[Loki Astari]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vector - Part 1: Resource Management Allocation]]></title>
    <link href="http://lokiastari.com/blog/2016/02/27/vector/"/>
    <updated>2016-02-27T12:00:31-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/27/vector</id>
    <content type="html"><![CDATA[<p>A lot of new developers to C++ attempt to build a <code>Vector</code> like container as a learning processes. Getting a simple version of this working for POD types (like int) is not that complicated. The next step in getting this working for arbitrary data types takes a significant leap forward in thinking in C++ especially when you start looking at efficiency and exception safety. This set of four articles looks at building an efficient <code>Vector</code> implementation. I show some of the common mistakes and explain why and how to resolve the problems:</p>

<ol>
<li>Resource Management I:   Allocation</li>
<li>Resource Management II:  Copy Assignment</li>
<li>Resource Management III: Simple Optimizations</li>
<li>Container Concepts.</li>
</ol>


<p>Note: This is not meant to replace <code>std::vector&lt;&gt;</code> this simply meant as a teaching processes.</p>

<h1>Rule of Zero</h1>

<p>You will notice that half the attempts above are Vector implementations the other half are for Matrix implementations. I mention both because I want to emphasize the <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>. An object should be responsible for either business logic or resource management (not both). A lot of the Matrix implementations are trying to mix resource management (memory management) with the business logic of how matrices interact. So if you want to write a matrix class you should delegate resource management to a separate class (In a first pass <code>std::vector&lt;int&gt;</code> would be a good choice).</p>

<p>In C++ the compiler generates a couple of methods for free.</p>

<ul>
<li>Destructor</li>
<li>Copy Constructor</li>
<li>Copy Assignment Operator</li>
<li>Move Constructor</li>
<li>Move Assignment Operator</li>
</ul>


<p>These methods usually work perfectly well; <strong>unless</strong> your class contains a pointer (or a pointer like resource object). But if your class is doing business logic then it should not contain a pointer. So classes that handle business logic therefore should not be defining any of these compiler generated methods (just let the compiler generated ones work for you). Occasionally you want to delete them, to prevent copying or movement, but it is very unusual for these to need specialized implementations.</p>

<p>Conversely, classes that do resource management usually contain a pointer (or pointer like resource object). These classes should define all the above methods to correctly handle the resource. This is where ownership semantics of the resource are defined. The owner of the resource is responsible for destroying the resource when its lifespan is over (in terms of pointers this means the owner is responsible for calling <code>delete</code> on the pointer, usually in the destructor). If you are not the owner of a resource you should not have access to the resource object directly, as it may be destroyed by the owner without other objects knowing.</p>

<h1><a href="http://stackoverflow.com/q/4172722/14065">Rule of three</a></h1>

<h2>Version-1 Simple Resource Management</h2>

<p>When creating a class to manage resources; the first version created by beginner usually looks like this:</p>

<p>```cpp Rule of three first pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])   // Allocate the resource
{}
~Vector()
{
    delete [] buffer;       // Clean up the resource
}
</code></pre>

<p>};
```
The trouble here is that this version has a fundamental flaw because of the way the <a href="http://stackoverflow.com/a/4044360/14065">compiler generated</a> copy constructor and copy assignment operator work with pointers (commonly referred to as the <a href="http://stackoverflow.com/q/2344664/14065">shallow copy problem</a>).</p>

<p>```cpp Shallow copy problem.
int main()
{</p>

<pre><code>Vector&lt;int&gt;   x;
Vector&lt;int&gt;   y(x);     // Compiler generate copy constructure does
                        // an element wise shallow copy of each element.
                        // This means both `x` and `y` have a buffer
                        // member that points at the same area in memory.
                        //
                        // When the objects go out of scope both will
                        // try and call delete on the memory resulting
                        // in a double delete of the memory.

Vector&lt;int&gt;   z;        // Same problem after an assignment.
z=x;
</code></pre>

<p>}
```</p>

<h2>Version-2 Rule of Three</h2>

<p>The rule of three simply stated is: If you define any of the methods Destructor/Copy Constructor/Copy Assignment Operator then you should define all three. When done correctly this resolves the shallow copy problem. <code>Vector</code> defines the destructor so we also need to define the copy constructor and copy assignment operator.</p>

<p>I see this as an initial attempt at defining the rule of three for vectors very often.</p>

<p>```cpp Rule of three second pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])
{}
~Vector()
{
    delete [] buffer;
}
Vector(Vector const&amp; copy)
    : size(copy.size)
    , buffer(new T[size])
{
    // Copy constructor is simple.
    // We create a new resource area of the required size.
    // Then we copy the data from the old buffer to the new buffer.
    std::copy(copy.buffer, copy.buffer + copy.size, copy);
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Version-3 Lazy Construction of elements.</h2>

<p>The problem with the previous version is that it forces initialization of all elements in the buffer immediately. This forces the requirement that members of the <code>Vector</code> (i.e. type <code>T</code>) must be default constructable. It also has two efficiency constraints imposed on the vector:</p>

<ul>
<li>You can&rsquo;t pre-allocate space for future members.

<ul>
<li>So resizing (larger or smaller) becomes very expensive as each resize requires copy all the elements to the newly re-sized buffer.</li>
<li>Alternatively pre-creating all the elements you need can also be expensive especially if construction of <code>T</code> is expensive.</li>
</ul>
</li>
<li>The copy constructor is twice as expensive as it should be. Each element must be:

<ul>
<li>Default constructed (when the buffer is created).</li>
<li>Then copy constructed with the value from the source vector.</li>
</ul>
</li>
</ul>


<p>This attempt improves on that by allowing efficient pre-allocating of space (<code>capacity</code>) for the buffer. New members are then added by constructing in place using <a href="http://stackoverflow.com/questions/362953/what-are-uses-of-the-c-construct-placement-new">placement new</a>.</p>

<p>```cpp Rule of three third pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
Vector(int capacity)
    : capacity(capacity = 100)
    , length(0)
    // Allocates space but does not call the constructor
    , buffer(static_cast&lt;int*&gt;(::operator new(sizeof(T) * capacity)))
    // Useful if the type T has an expensive constructor
    // We preallocate space without initializing it giving
    // room to grow and shrink the buffer without re-allocating.
{}
~Vector()
{
    // Because elements are constructed in place using
    // placement new. Then we must manually call the destructor
    // on the elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Note we destroy the elements in reverse order.
        buffer[length - 1 - loop].~T();
    }
    ::operator delete(buffer);
}
Vector(Vector const&amp; copy)
    : capacity(copy.length)
    , length(0)
    , buffer(static_cast&lt;int*&gt;(::operator new(sizeof(T) * capacity)))
{
    // Copy constructor is simple.
    // We create a new resource area of the required length.
    // But these elements are not initialized so we use push_back to copy them
    // into the new object. This is an improvement because we
    // only construct the members of the vector once.
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
void push_back(T const&amp; value)
{
    // Use placement new to copy buffer into the new buffer
    new (buffer + length) T(value);
    ++length;

    // Note we will handle growing the capacity later.
}
void pop_back()
{
    // When removing elements need to manually call the destructor
    // because we created them using placement new.
    --length;
    buffer[length].~T();
}
</code></pre>

<p>};
```</p>

<h1>Rule of Five</h1>

<p>In C++11 the language add the concept of &ldquo;Move Semantics&rdquo;. Rather than having to copy an object (especially on return from a function) we could &ldquo;move&rdquo; an object. The concept here is that movement is supposed to be much cheaper than copy because you move the internal data structure of an object rather than all the elements. A good example is a std::vector. Pre C++11 a return by value means copying the object. The constructor of the new object allocates a new internal buffer and then copies all the elements from the original objects buffer to the new objects buffer. On the other hand a move simply gives the new object the internal buffer of the old object (we just move the pointer to the internal buffer). When an object is moved to another object the old object should be left in a valid state, but for efficiency the standard rarely specifies the state of an object after it has been the source of a move. Thus using an object after a move is a bad idea unless you are setting it to a specific state.</p>

<p>There are two new method that allow us to specify move semantics on a class.</p>

<p>```cpp Vector Move Semantics.
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept;

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept;
</code></pre>

<p>};
```</p>

<p>Notice the <code>&amp;&amp;</code> operator. This donates an r-value reference and means that your object is the destination of a move operation. The parameter passed is the source object and the state you should use to define your new objects state. After the move the source object must be left in a valid (but can be undefined state). For a vector this means it must no longer be the owner of the internal buffer that you are now using in your buffer.</p>

<p>The simplest way to achieve this goal is to set up the object in a valid (but very cheap to achieve state) and then swap the current object with the destination object.</p>

<p>```cpp Vector Move Semantics Implementation
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept
    : capacity(0)
    , length(0)
    , buffer(nullptr)
{
    // The source object now has a nullptr/
    // This object has taken the state of the source object.
    move.swap(*this);
}

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept
{
    // In this case simply swap the source object
    // and this object around.
    move.swap(*this);
}
</code></pre>

<p>};
```</p>

<p>Note I marked both move operators <code>noexcept</code>. Assuming the operations are guaranteed not to throw you should mark them as <code>noexcept</code>. If we know that certain operations are exception safe, then we can optimize resize operations and maintain the strong exception guarantee. This and some other optimizations will be documented in a subsequent post.</p>

<h1>Final Version</h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;int*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;int*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_backValue(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            ::operator delete(buffer);

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Covered in Part 2
        return *this;
    }
    Vector(Vector&amp;&amp; move)
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move)
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        new (buffer + length) T(value);
        ++length;
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            // Covered in Part 2
        }
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has shown how to handle the basic resource management required by a vector. It has covered several important principles for C++ programmers.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Rule of Zero</li>
<li>Rule of Three</li>
<li>Rule of Five</li>
<li>Default compiler generated methods</li>
<li>Shallow Copy Problem</li>
<li>Placement New</li>
<li>Exception Grantees</li>
</ul>


<h1>Sources</h1>

<p>Looking at <a href="http://CodeReview.stackexchange.com">CodeReview.stackexchange.com</a>; reimplementing the vector class is a common goal for a first project.</p>

<ul>
<li>2011/Nov/07 &ndash; <em><a href="http://codereview.stackexchange.com/q/5856/507">Mathematical Vector2 class implementation</a></em></li>
<li>2012/May/21 &ndash; <em><a href="http://codereview.stackexchange.com/q/11934/507">C++ Vector2 Class Review</a></em></li>
<li>2012/Aug/17 &ndash; <a href="http://codereview.stackexchange.com/q/14784/507">Templated Matrix class</a></li>
<li>2013/Jan/07 &ndash; <a href="http://codereview.stackexchange.com/q/20243/507">Vector implementation &ndash; simple replacement</a></li>
<li>2013/May/25 &ndash; <a href="http://codereview.stackexchange.com/q/26608/507">Review of 2d Vector class</a></li>
<li>2013/Jun/19 &ndash; <a href="http://codereview.stackexchange.com/q/27573/507">Simple matrix class</a></li>
<li>2013/Jun/21 &ndash; <em><a href="http://codereview.stackexchange.com/q/27625/507">Matrix and Vector4 classes</a></em></li>
<li>2013/Jun/25 &ndash; <em><a href="http://codereview.stackexchange.com/q/27752/507">Simple matrix class &ndash; version 2</a></em></li>
<li>2013/Aug/03 &ndash; <em><a href="http://codereview.stackexchange.com/q/29331/507">Template vector class</a></em></li>
<li>2014/Feb/20 &ndash; <a href="http://codereview.stackexchange.com/q/42297/507">C++ vector implementation</a></li>
<li>2014/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/43136/507">Reimplementation of C++ vector</a></li>
<li>2014/Mar/12 &ndash; <a href="http://codereview.stackexchange.com/q/44167/507">3D mathematical vector class</a></li>
<li>2014/May/17 &ndash; <a href="http://codereview.stackexchange.com/q/50975/507">Creating a custom Vector class</a></li>
<li>2014/Aug/19 &ndash; <a href="http://codereview.stackexchange.com/q/60484/507">STL vector implementation</a></li>
<li>2014/Sep/12 &ndash; <a href="http://codereview.stackexchange.com/a/62774/507">C++ 3D Vector Implementation</a></li>
<li>2014/Sep/26 &ndash; <a href="http://codereview.stackexchange.com/q/63970/507">Custom mathematical vector class</a></li>
<li>2014/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/67209/507">Vector backed by memory pages</a></li>
<li>2014/Oct/31 &ndash; <a href="http://codereview.stackexchange.com/q/68486/507">Custom matrix class</a></li>
<li>2014/Nov/25 &ndash; <a href="http://codereview.stackexchange.com/q/70815/507">Vector/matrix class</a></li>
<li>2014/Dec/22 &ndash; <a href="http://codereview.stackexchange.com/q/74521/507">Vector implementation</a></li>
<li>2015/Feb/17 &ndash; <a href="http://codereview.stackexchange.com/q/81751/507">Mathematical matrices implementation</a></li>
<li>2015/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/82906/507">C++ vector implementation errors</a></li>
<li>2015/Jun/20 &ndash; <a href="http://codereview.stackexchange.com/q/94211/507">Implementation of std::vector class</a></li>
<li>2015/Jul/08 &ndash; <a href="http://codereview.stackexchange.com/q/96253/507">Second implementation of std::vector</a></li>
<li>2015/Oct/17 &ndash; <a href="http://codereview.stackexchange.com/q/107877/507">Simple multi-dimensional Array class in C++11</a></li>
<li>2015/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/108072/507">Creating n-dimensional mathematical vector classes through inheritance</a></li>
<li>2015/Oct/20 &ndash; <a href="http://codereview.stackexchange.com/q/108140/507">Implementation of Vector in C++</a></li>
<li>2015/Oct/23 &ndash; <a href="http://codereview.stackexchange.com/q/108558/507">Simple multi-dimensional Array class in C++11 &ndash; follow-up</a></li>
<li>2015/Nov/18 &ndash; <a href="http://codereview.stackexchange.com/q/111114/507">Custom vector that uses less memory than std::vector</a></li>
<li>2015/Nov/24 &ndash; <a href="http://codereview.stackexchange.com/q/111746/507">Attempt at templates by creating a class for N-dimensional mathematical vectors</a></li>
<li>2016/Jan/10 &ndash; <a href="http://codereview.stackexchange.com/q/116377/507">Vector Implementation C++</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart Pointer Constructors]]></title>
    <link href="http://lokiastari.com/blog/2015/01/23/c-plus-plus-by-example-smart-pointer-part-iii/"/>
    <updated>2015-01-23T16:33:14-08:00</updated>
    <id>http://lokiastari.com/blog/2015/01/23/c-plus-plus-by-example-smart-pointer-part-iii</id>
    <content type="html"><![CDATA[<p>In this article we examine constructors that are often missed or overlooked. This article looks at the use cases for these constructors and explains why the added functionality provides a meaningful addition in relation to smart pointers.</p>

<h2>Default Constructor</h2>

<p>Most people remember the default constructor (a zero argument constructor), but every now and then it gets missed.</p>

<p>The default constructor is useful when the type is used in a context where objects of the type need to be instantiated dynamically by another library (an example is a container resized; when a container is made larger by a resize, new members will need to be constructed, it is the default constructor that will provide these extra instances).</p>

<p>The default constructor is usually very trivial and thus worth the investment.
```cpp Smart Pointer Default Constructor</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            UP()
                : data(nullptr)
            {}
            .....
    };
}
</code></pre>

<p>```</p>

<h2>The nullptr</h2>

<p>In C++11 the <code>nullptr</code> was introduced to replace the old broken <code>NULL</code> and/or the even more broken <code>0</code> for use in contexts where you want a pointer that points at nothing. The <code>nullptr</code> is automatically convert to any pointer type or a boolean; but fixed the previous bug (or bad feature) and will not convert to a numeric type.
```cpp nullptr Usage Example</p>

<h1>include <string></h1>

<pre><code>int main()
{
    char*           tmp = nullptr;   // converts the nullptr (type std::nullptr_t) to char*
    std::string*    str = nullptr;   // hopefully you never do that! but it works.

    bool            tst = nullptr;   // False. Yes I know it does not look that useful.
                                     //        But when you consider all the funny things
                                     //        that can happen with templates this can
                                     //        be very useful.

    int             val = nullptr;   // Fails to compile.
    int             val = NULL;      // Pointer assigned to integer value.
                                     // Works just fine. But very rarely was this a useful
                                     // feature (more usually an over-site that was not
                                     // reported by the compiler).
}
</code></pre>

<p><code>
The `nullptr` provides some opportunities to make the code shorter/cleaner when initializing smart pointers to be empty. Because we are using explicit one argument constructors the compiler can not convert a `nullptr` into a smart pointer automatically, it must be done explicitly by the developer.
</code>cpp nullptr failing on Smart Pointer</p>

<pre><code>void workWithSP(ThorsAnvil::UP&lt;int&gt;&amp;&amp; sp)
{ /* STUFF*/ }

int main()
{
    // This fails to compile.
    workWithSP(nullptr);

    // Need to be explicit with smart pointers
    workWithSP(ThorsAnvil::UP&lt;int&gt;(nullptr));
}
</code></pre>

<p><code>
This is overly verbose, there is no danger involved in forming a smart pointer around a `nullptr` automatically. Because `nullptr` has its own type `std::nullptr_t` we can add a constructor to explicitly simplify this case, which makes it easier to read.
</code>cpp Smart Pointer with std::nullptr_t constructor</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        public:
            UP(std::nullptr_t)
                : data(nullptr)
            {}
    ....
    };
}
// Now we can simplify our use case
void workWithSP(ThorsAnvil::UP&lt;int&gt;&amp;&amp; sp)
{ /* STUFF*/ }

int main()
{
    workWithSP(nullptr);

    // Note this also allows:
    ThorsAnvil::UP&lt;int&gt;   data  = nullptr;
    // And
    data = nullptr;       // Note here we have we convert nullptr to
                          // smart pointer using the one argument
                          // constructor that binds `nullptr` then
                          // call the assignment operator.
                          //
                          // That seems like a lot extra work. So we
                          // may as well define the assignment operator
                          // to specifically user `nullptr`.
}
</code></pre>

<p>```</p>

<h2>Move Semantics</h2>

<p>Move semantics were introduced with C++ 11. So though we can not copy the <code>ThorsAnvil::UP</code> object it can be moved. The compiler will generate a default move constructor for a class under certain situations; but because we have defined a destructor for <code>ThorsAnvil::UP</code> we must manually define the move constructor.</p>

<p>Move semantics say that the source object may be left in an undefined (but must be valid) state. So the easiest way to implement this is simply to swap the state of the current object with the source object (we know our state is valid so just swap it with the incoming object state (its destructor will then take care of destroying the pointer we are holding)).
```cpp Smart Pointer Move Semantics</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            // Swap should always be `noexcept` operation
            void swap(UP&amp; src) noexcept
            {
                std::swap(data, src.data);
            }
            // It is a good idea to make your move constructor `noexcept`
            // In this case it actually makes no difference (because there
            // no copy constructor) but to maintain good practice I still
            // think it is a good idea to mark it with `noexcept`.
            UP(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
            }
            UP&amp; operator=(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
                return *this;
            }
            .....
    };
    template&lt;typename T&gt;
    void swap(UP&lt;T&gt;&amp; lhs, UP&lt;T&gt;&amp; rhs)
    {
        lhs.swap(rhs);
    }
}
</code></pre>

<p>```</p>

<h2>Derived Type Assignment.</h2>

<p>Assigning derived class pointers to a base class pointer object is quite common feature in C++.
```cpp Derived Example</p>

<pre><code>class Base
{
    public:
        virtual ~Base() {}
        virtual void doAction() = 0;
};
class Derived1: public Base
{
    public:
        virtual void doAction() override;
};
class Derived2: public Base
{
    public:
        virtual void doAction() override;
};
int main(int argc, char* argv[])
{
    Derived1*   action1 = new Derived1;
    Derived2*   action2 = new Derived2;

    Base*       action   = (argc == 2) ? action1 : action2;
    action-&gt;doAction();
}
</code></pre>

<p><code>
If we try the same code with the constructors we currently have we will get compile errors.
</code>cpp Derived Example with Smart Pointers</p>

<pre><code>int main(int argc, char* argv[])
{
    ThorsAnvil::UP&lt;Derived1&gt;    action1 = new Derived1;
    ThorsAnvil::UP&lt;Derived2&gt;    action2 = new Derived2;

    ThorsAnvil::UP&lt;Base&gt;        action   = std::move((argc == 2) ? action1 : action2);
    action-&gt;doAction();
}
</code></pre>

<p><code>``
This is because C++ considers</code>ThorsAnvil::UP<Derived1><code>,</code>ThorsAnvil::UP<Derived2><code>and</code>ThorsAnvil::UP<Base>` are three distinct classes that are unrelated. As this kind of pointer usage is rather inherent in how C++ is used the smart pointer needs to be designed for this use case.</p>

<p>To solve this we need to allow different types of smart pointer be constructed from other types of smart pointer, but only where the inclosed types are related.
```cpp Derived Smart Pointer transfer</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            // Release ownership of the pointer.
            // Returning the pointer to the caller.
            T*  release()
            {
                T* tmp = nullptr;
                std::swap(tmp, data);
                return tmp;
            }
            // Note: If you try calling this with a U that is not derived from
            //       a T then the compiler will generate a compilation error as
            //       the pointer assignments will not match correctly.
            template&lt;typename U&gt;
            UP(UP&lt;U&gt;&amp;&amp; moving)
            {
                // We can not use swap directly.
                // Even though U is derived from T, the reverse is not true.
                // So we have put it in a temporary locally first.

                // Note: this is still exception safe.
                //       The normal constructor will call delete even if it does
                //       not finish constructing. So if release completes even
                //       starting the call to the constructor guarantees its safety.
                UP&lt;T&gt;   tmp(moving.release());
                tmp.swap(*this);
            }
            template&lt;typename U&gt;
            UP&amp; operator=(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;    tmp(moving.release());
                tmp.swap(*this);
                return *this;
            }
            .....
    };
}
</code></pre>

<p>```</p>

<h2>Updated Unique Pointer</h2>

<p>Combine the constructor/assignment operators discussed in this article with the <code>ThorsAnvil::UP</code> that we defined in the first article in the series: <a href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">Unique Pointer</a> we obtain the following:
```cpp ThorsAnvil::UP Version 3</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*   data;
        public:
            UP()
                : data(nullptr)
            {}
            // Explicit constructor
            explicit UP(T* data)
                : data(data)
            {}
            ~UP()
            {
                delete data;
            }

            // Constructor/Assignment that binds to nullptr
            // This makes usage with nullptr cleaner
            UP(std::nullptr_t)
                : data(nullptr)
            {}
            UP&amp; operator=(std::nullptr_t)
            {
                reset();
                return *this;
            }

            // Constructor/Assignment that allows move semantics
            UP(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
            }
            UP&amp; operator=(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
                return *this;
            }

            // Constructor/Assignment for use with types derived from T
            template&lt;typename U&gt;
            UP(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;   tmp(moving.release());
                tmp.swap(*this);
            }
            template&lt;typename U&gt;
            UP&amp; operator=(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;    tmp(moving.release());
                tmp.swap(*this);
                return *this;
            }

            // Remove compiler generated copy semantics.
            UP(UP const&amp;)            = delete;
            UP&amp; operator=(UP const&amp;) = delete;

            // Const correct access owned object
            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}

            // Access to smart pointer state
            T* get()                 const {return data;}
            explicit operator bool() const {return data;}

            // Modify object state
            T* release() noexcept
            {
                T* result = nullptr;
                std::swap(result, data);
                return result;
            }
            void swap(UP&amp; src) noexcept
            {
                std::swap(data, src.data);
            }
            void reset()
            {
                T* tmp = releae();
                delete tmp;
            }
    };
    template&lt;typename T&gt;
    void swap(UP&lt;T&gt;&amp; lhs, UP&lt;T&gt;&amp; rhs)
    {
        lhs.swap(rhs);
    }
}
</code></pre>

<p>```</p>

<h2>Summary</h2>

<p>In the last two articles (<a href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">Unique Pointer</a> and <a href="http://lokiastari.com/blog/2015/01/15/c-plus-plus-by-example-smart-pointer-part-ii/">Shared Pointer</a>) we covered some basic mistakes that I have often seen developers make when attempting to creating their own smart pointer. I also introduce four important C++ concepts:</p>

<ul>
<li><a href="http://stackoverflow.com/q/4172722/14065">Rule of Three</a></li>
<li><a href="http://stackoverflow.com/q/3279543/14065">Copy and Swap Idiom</a></li>
<li><a href="http://stackoverflow.com/a/121163/14065">Explicit One Argument Constructor</a></li>
<li><a href="http://stackoverflow.com/q/12697625/14065">Try/Catch on Initialization List</a></li>
</ul>


<p>This article I focused on a couple of constructors/assignment operators that can be overlooked overlooked.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shared Pointer]]></title>
    <link href="http://lokiastari.com/blog/2015/01/15/c-plus-plus-by-example-smart-pointer-part-ii/"/>
    <updated>2015-01-15T08:13:47-08:00</updated>
    <id>http://lokiastari.com/blog/2015/01/15/c-plus-plus-by-example-smart-pointer-part-ii</id>
    <content type="html"><![CDATA[<p>So in <a href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">the previous article</a> I covered a basic <code>unique</code> pointer where the smart pointer retained sole ownership of the pointer. The other common smart pointer we encounter is the <code>shared</code> pointer (SP). In this case the ownership of the pointer is shared across multiple instances of SP and the pointer is only released (deleted) when all SP instances have been destroyed.</p>

<p>So not only do we have to store the pointer but we need a mechanism for keeping track of all the SP instances that are sharing ownership of the pointer. When the last SP instance is destroyed it also deletes the pointer (The last owner cleans up. A similar principle to the last one to leave the room turns out the lights).
```cpp Shared Pointer contextual destructor</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class SP
    {
        T*  data;
        public:
            ~SP()
            {
                if (amITheLastOwner())
                {
                    delete data;
                }
            }
    };
}
</code></pre>

<p>```
There are two major techniques for tracking the shared owners of a pointer:</p>

<ol>
  <li>Keep a count:</li>
  <ul>
    <li>When the count is 1 you are the last owner.</li>
    <li>This is a very simple and logical technique. You have a shared counter that is incremented/decrement as SP instances take/release ownership of the pointer. The disadvantages are that you need dynamically allocated memory that must be managed and in a threaded environment you need to serialize accesses to counter.</li>
  </ul>
  <li>Use a linked list of the owners:</li>
  <ul>
    <li>When you are the only member of the list you are the last owner.</li>
    <li>When a SP instance take/releases ownership of the pointer they are added/removed to/from the linked list. This is slightly more complex as you need to maintain a circular linked list (for O(1)). The advantage is that you do not need to manage any separate memory for the count (A SP instance simply points at the next SP instance in the chain) and in a threaded environment adding/removing a shared pointer need not always be serialized (though you will still need to lock your neighbors to enforce integrity).</li>
  </ul>
</ol>


<h2>Shared Count</h2>

<p>The easier of the two to implement correctly is the list version. There are no real gotchas (that I have seen). Though people do struggle with insertion and removal of a link from a circular list. I have another article planned for that at some point so I will cover it then.</p>

<p>The <em>Shared Count</em> is basically the technique used by the <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a> (though they store slightly more than the count to try and improve efficiency see <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared"><code>std::make_shared</code></a>).</p>

<p>The main mistake I see from beginners is not using dynamically allocated counter (ie they keep the counter in the SP object). You <strong>must</strong> dynamically allocate memory for the counter so that it can be shared by all SP instances (you can not tell how many there will be or the order in which they will be deleted).</p>

<p>You must also serialize access to this counter to make sure that in a threaded environment the count is correctly maintained. In the first version for simplicity I will only consider single threaded environments and thus synchronization is not required.
```cpp First Try</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class SP
    {
        T*      data;
        int*    count;
        public:
            // Remember from ThorsAnvil::UP that the constructor
            // needs to be explicit to prevent the compiler creating
            // temporary objects on the fly.
            explicit SP(T* data)
                : data(data)
                , count(new int(1))
            {}
            ~SP()
            {
                --(*count);
                if (*count == 0)
                {
                    delete data;
                }
            }
            // Remember from ThorsAnvil::UP that we need to make sure we
            // obey the rule of three. So we will implement the copy
            // constructor and assignment operator.
            SP(SP const&amp; copy)
                : data(copy.data)
                , count(copy.count)
            {
                ++(*count);
            }
            SP&amp; operator=(SP const&amp; rhs)
            {
                // Keep a copy of the old data
                T*   oldData  = data;
                int* oldCount = count;

                // now we do an exception safe transfer;
                data  = rhs.data;
                count = rhs.count;

                // Update the counters
                ++(*count);
                --(*oldCount);

                // Finally delete the old pointer if required.
                if (*oldCount == 0)
                {
                    delete oldData;
                }
            }
            // Const correct access owned object
            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}

            // Access to smart pointer state
            T* get()                 const {return data;}
            explicit operator bool() const {return data;}
    };
}
</code></pre>

<p>```</p>

<h3>Problem 1: Potential Constructor Failure</h3>

<p>When a developer (attempts) to create a SP they are handing over ownership of the pointer to the SP instance. Once the constructor starts there is an expectation by the developer that no further checks are needed. But there is a problem with the code as written.</p>

<p>In C++ memory allocation through new does not fail (unlike C where <code>malloc()</code> can return a Null on failure). In C++ a failure to allocate memory via the standard new generates a <code>std::bad_alloc</code> exception. Additionally if we throw an exception out of a constructor the destructor will never be called (the destructor is only called on fully formed objects) when the instance&rsquo;s lifespan ends.</p>

<p>So if an exception is thrown during construction (and thus the destructor will not be called) we must assume responsibility for making sure that pointer is deleted before the exception escapes the constructor, otherwise there will be a resultant leak of the pointer.
```cpp Constructor takes responsibility for pointer</p>

<pre><code>namespace ThorsAnvil
{
     .....
             explicit SP(T* data)
                : data(data)
                , count(new (std::nothorw) int(1)) // use the no throw version of new.
            {
                // Check if the pointer correctly allocated
                if (count == nullptr)
                {
                    // If we failed then delete the pointer
                    // and manually throw the exception.
                    delete data;
                    throw std::bad_alloc();
                }
            }
            // or
     .....
            explicit SP(T* data)
            // The rarely used try/catch for exceptions in argument lists.
            try
                : data(data)
                , count(new int(1))
            {}
            catch(...)
            {
                // If we failed because of an exception
                // delete the pointer and rethrow the exception.
                delete data;
                throw;
            }
}
</code></pre>

<p>```</p>

<h3>Problem 2: DRY up the Assignment</h3>

<p>Currently the assignment operator is exception safe and conforms to the strong exception guarantee so there is no real problem here. <strong>But</strong> there seems to be a lot of duplicated code in the class.
```cpp Closer look at assignment</p>

<pre><code>namespace ThorsAnvil
{
     .....
            SP&amp; operator=(SP const&amp; rhs)
            {
                T*   oldData  = data;
                int* oldCount = count;

                data  = rhs.data;
                count = rhs.count;                    
                ++(*count);

                --(*oldCount);
                if (*oldCount == 0)
                {
                    delete oldData;
                }
            }
}
</code></pre>

<p>```
Two portions of this look like other code pieces of code that have already been written:</p>

<pre><code>// This looks like the SP copy constructor.
                data  = rhs.data;
                count = rhs.count;                    
                ++(*count);

// This looks like the SP destructor.
                --(*oldCount);
                if (*oldCount == 0)
                {
                    delete oldData;
                }
</code></pre>

<p>This observation is commonly referred to as the <strong><a href="http://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">Copy and Swap Idiom</a></strong>. I will not go through all the details of the transformation here. But we can re-write the assignment operator as:
```cpp Copy and Swap Idiom</p>

<pre><code>            SP&amp; operator=(SP const&amp; rhs)
            {
                // constructor of tmp handles increment.
                SP tmp(rhs);

                std::swap(data,  tmp.data);
                std::swap(count, tmp.count);
                return *this;
            }   // the destructor of tmp is executed here.
                // this handles the decrement and release of the pointer

     // This is usually simplified further into
            SP&amp; operator=(SP rhs) // Note implicit copy because of pass by value.
            {
                rhs.swap(*this);  // swaps moved to swap method.
                return *this;
            }
</code></pre>

<p>```</p>

<h2>Fixed First Try</h2>

<p>So given the problems described above we can update our implementation to compensate for these issues:
```cpp Fixed First Try</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class SP
    {
        T*      data;
        int*    count;
        public:
            // Explicit constructor
            explicit SP(T* data)
            try
                : data(data)
                , count(new int(1))
            {}
            catch(...)
            {
                // If we failed because of an exception
                // delete the pointer and rethrow the exception.
                delete data;
                throw;
            }
            ~SP()
            {
                --(*count);
                if (*count == 0)
                {
                    delete data;
                }
            }
            SP(SP const&amp; copy)
                : data(copy.data)
                , count(copy.count)
            {
                ++(*count);
            }
            // Use the copy and swap idiom
            // It works perfectly for this situation.
            SP&amp; operator=(SP rhs)
            {
                rhs.swap(*this);
                return *this;
            }
            SP&amp; operator=(T* newData)
            {
                SP tmp(newData);
                tmp.swap(*this);
                return *this;
            }
            // Always good to have a swap function
            // Make sure it is noexcept
            void swap(SP&amp; other) noexcept
            {
                std::swap(data,  other.data);
                std::swap(count, other.count);
            }
            // Const correct access owned object
            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}

            // Access to smart pointer state
            T* get()                 const {return data;}
            explicit operator bool() const {return data;}
        };
}
</code></pre>

<p>```</p>

<h2>Summary</h2>

<p>So in this second post we have looked SP and mentioned the two main implementation techniques commonly used. We specifically looked in detail at some common problems usually overlooked in the counted implementation of SP. In the next article I want to look at a couple of other issues common to both types of smart pointers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Pointer]]></title>
    <link href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/"/>
    <updated>2014-12-30T18:41:42-08:00</updated>
    <id>http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer</id>
    <content type="html"><![CDATA[<p>On <a href="codereview.stackexchange.com">codereview.stackexchange.com</a> in the C++ tag it seems that it is a write of passage to implement your own version of a smart pointer. A quick search brings up the following:</p>

<ul>
<li>02/Sep/2011 &ndash; <a href="http://codereview.stackexchange.com/q/4550/507">shared_ptr implementation</a></li>
<li>26/Nov/2011 &ndash; <a href="http://codereview.stackexchange.com/q/6320/507">Shared Pointer implementation</a></li>
<li>18/Apr/2013 &ndash; <a href="http://codereview.stackexchange.com/q/25214/507">Request for review: reference counting smart pointer</a></li>
<li>20/May/2013 &ndash; <a href="http://codereview.stackexchange.com/q/26353/507">Efficient smart pointer implementation in C++</a></li>
<li>11/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/29629/507">C++98 Unique Pointer Implementation</a></li>
<li>14/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/29734/507">I wrote a class to implement auto_ptr</a></li>
<li>28/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/30398/507">yet another shared pointer</a></li>
<li>04/Mar/2014 &ndash; <a href="http://codereview.stackexchange.com/q/43472/507">Smart pointer implementation</a></li>
<li>13/May/2014 &ndash; <a href="http://codereview.stackexchange.com/q/49672/507">One more shared pointer</a></li>
<li>14/Jun/2014 &ndash; <a href="http://codereview.stackexchange.com/q/54220/507">Is this a meaningful Intrusive Pointer Class?</a></li>
<li>04/Aug/2014 &ndash; <a href="http://codereview.stackexchange.com/q/59004/507">Simple shared pointer</a></li>
<li>08/Oct/2014 &ndash; <a href="http://codereview.stackexchange.com/q/65127/507">Smart but simple pointers</a></li>
<li>15/Nov/2014 &ndash; <a href="http://codereview.stackexchange.com/q/69943/507">Simple auto_ptr</a></li>
<li>19/Dec/2014 &ndash; <a href="http://codereview.stackexchange.com/q/74166/507">Yet another smart pointer implementation for learning</a></li>
</ul>


<p>Writing you own implementation of a smart pointer is a bad idea (IMO). The standardization and testing of smart pointers was a nine year process through <a href="http://www.boost.org/">boost</a>, with <a href="http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a> and <a href="http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/scoped_ptr.htm">boost::scoped_ptr</a>, finally resulting in the standardized versions being released in C++11: <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> and <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>.</p>

<p>I would even say that I dislike the smart pointer as a learning device; it seems like a very simple project for a newbie, but in reality (as indicated by the nine year standardization processes) getting it working correctly in all contexts is rather a complex endeavor.</p>

<p>But because it is such a frequent request for review; I want take a look at smart pointers as a teaching exercise. In the next couple of articles I will step through the processes of building a smart pointer and look at some of the common mistakes that I see (and probably make a few as I go).</p>

<h3>Warning:</h3>

<p>This article is not for absolute beginners. I assume you already know the basics of C++.</p>

<h2>First Bash</h2>

<p>So lets get started. The two most common smart pointers are <code>unique</code> and <code>shared</code>. So lets start with the one that seems the simplest (<code>unique</code>)and see where we go.</p>

<p>It would seem that we could bash out a quick unique pointer like this:
```cpp ThorsAnvil::UP Version 1</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*   data;
        public:
            UP(T* data)
                : data(data)
            {}
            ~UP()
            {
                delete data;
            }
            T* operator-&gt;() {return data;}
            T&amp; operator*()  {return *data;}
            T* release()
            {
                T* result = nullptr;
                std::swap(result, data);
                return result;
            }
            // So it can be used in conditional expression
            operator bool() {return data;}
    };
}
</code></pre>

<p>```</p>

<h3>Problem 1: Rule of Three Violation</h3>

<p>The first problem here is that we are not obeying the &ldquo;<a href="http://stackoverflow.com/q/4172722/14065">rule of three</a>&rdquo;. Since we have a destructor that does memory management we should also handle the copy constructor and assignment operator. Otherwise the following is allowed and will cause undefined behavior:
```cpp Rule of Three Copy Constructor</p>

<pre><code>int test1()
{
    ThorsAnvil::SP   sp1&lt;int&gt;(new int(5));
    ThorsAnvil::SP   sp2&lt;int&gt;(sp1);  // copy construction

             // Here the compiler generated copy constructor
             // kicks in and does a member wise copy of sp1
             // into sp2. That in itself is not a problem.
 }
 // But when sp2 goes out of scope its destructor kicks in
 // and deletes the pointer. When sp1 subsequently follows
 // sp2 out of scope it will also call delete on the same
 // pointer (as they share a copy of the pointer).
 // 
 // This is known as a double delete and causes
 // undefined behavior (UB).
</code></pre>

<p>```</p>

<p> The assignment operator is slightly worse:
```cpp Rule of Three Assignment Operator</p>

<pre><code>int test2()
{
    ThorsAnvil::SP   sp1&lt;int&gt;(new int(5));
    ThorsAnvil::SP   sp2&lt;int&gt;(new int(6));

    sp2 = sp1; // Assignment operation.

             // Here the compiler generated assignment 
             // operator kicks in and does a member wise 
             // assignment of sp1 into sp2.
             //
             // The main problem with the assignment here
             // is that we have lost the original pointer
             // that sp2 was holding.
 }
 // Same issues with double delete as the copy constructor.
</code></pre>

<p><code>
This is caused by the compiler atomically generating default implementations of certain methods (see discussion on the [rule of three](http://stackoverflow.com/q/4172722/14065)) if the user does not explicitly specify otherwise. In this case the problem comes because of the compiler generated versions of the copy constructor and assignment operator (see below)
</code>cpp Compiler Generated Methods.</p>

<pre><code>namespace ThorsAnvil
{
    .....
        // Compiler Generated Copy Constructor
        UP(UP const&amp; copy)
            : data(copy.data)
        {}

        // Compiler Generated Assignment Operator
        UP&amp; UP::operator=(UP const&amp; rhs)
        {
            data    = rhs.data;
            return *this;
        }
}
</code></pre>

<p>```
I have heard this described as a language bug; but I have to disagree with that sentiment, as these compiler generated methods do exactly as you would expect in nearly all situations. The one exceptions is when the class contains &ldquo;owned raw pointers&rdquo;.</p>

<h3>Problem 2: Implicit construction.</h3>

<p>The next issue is caused by C++ tendency to eagerly convert one type to another if given half a chance. If your class contains a constructor that takes a single argument then the compiler will use this as a way of converting one type to another.
```cpp Example</p>

<pre><code>void takeOwner1(ThorsAnvil::UP&lt;int&gt; x)
{}
void takeOwner2(ThorsAnvil::UP&lt;int&gt; const&amp; x)
{}
void takeOwner3(ThorsAnvil::UP&lt;int&gt;&amp;&amp; x)
{}
int main()
{
    int*   data = new int(7);

    takeOwner1(data);
    takeOwner2(data);
    takeOwner3(data);
}
</code></pre>

<p><code>``
Though none of the functions in the example take an</code>int pointer<code>as a parameter; the compiler sees that it can convert an</code>int*<code>into an object of type</code>ThorsAnvil::UP<int>` via the single argument constructor and builds temporary objects to facilitate the calling of the function.</p>

<p>In the case of smart pointers, that take ownership of the object passed in the constructor, this can be a problem because the lifetime of a temporary object is the containing statement (with a few exceptions that we will cover in another article). As a simple rule of thumb you can think of the lifespan of a temporary ending at the <code>';'</code>.
```cpp Temporary Object</p>

<pre><code>takeOwner1(data);

// You can think of this as functionally equivalent to:

{
    ThorsAnvil::UP&lt;int&gt; tmp(data);
    takeOwner1(tmp);
}
</code></pre>

<p><code>``
The problem here is that when</code>tmp<code>goes out of scope its destructor will call delete on the pointer. Thus</code>data<code>is now pointing at memory that has been destroyed (and thus no longer belongs to the application). Any further use of</code>data` is going to potentially cause problems (and I am being generous using the word potentially).</p>

<p>This feature can be quite useful (when you want this conversion to happen easily, see std::string). But you should definitely be aware of it and think carefully about creating single argument constructors.</p>

<h3>Problem 3: Null de-referencing</h3>

<p>I think it is obvious that <code>operator*</code> has an issue with de-referencing a Null pointer here:
```cpp operator*()</p>

<pre><code>            T&amp; operator*()  {return *data;}
</code></pre>

<p><code>
But it is not quite as obvious that `operator-&gt;` is also going to cause dereferencing of the pointer here:
</code>cpp operator->()</p>

<pre><code>            T* operator-&gt;() {return data;}
</code></pre>

<p><code>``
There are a couple of solutions to this problem. You can check</code>data` and throw an exception if it is a Null pointer, or alternatively you can make it a pre-condition on the usage of the smart pointer (ie it is the responsibility of the user to either know or check the state of the smart pointer before using these methods).</p>

<p>The standard has chosen to go with a pre-condition (a very common C++ practice: do not impose an overhead on all your users (to spare problems for the beginner), but rather provide a mechanism to check the state for those that need to do so; so they can choose to pay the overhead when they need to and not every time). We can do the same here but we have not provided any mechanism for the user to check the state of the smart pointer.</p>

<h3>Problem 4: Const Correctness</h3>

<p>When accessing the owned object via a smart pointer we are not affecting the state of our smart pointer so any member that basically returns the object (without changing the state of the smart pointer) should be marked const.
```cpp Not const</p>

<pre><code>            T* operator-&gt;() {return data;}
            T&amp; operator*()  {return *data;}
</code></pre>

<p><code>
So these two methods should really be declared as:
</code>cpp Const Correct</p>

<pre><code>            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}
</code></pre>

<p>```</p>

<h3>Problem 5: Bool conversion to easy</h3>

<p>The current <code>operator bool()</code> works as required in bool expressions.
```cpp Check for value</p>

<pre><code>ThorsAnvil::UP&lt;int&gt;    value(new int(4));

if (value) {
    std::cout &lt;&lt; "Not empty\n";
}
</code></pre>

<p><code>
But the compiler will also use the conversion operators when it is trying to coerce objects that nearly match. For example you can now test two `UP` with `operator==` even though there does not exists an actual `operator==` for the `UP&lt;&gt;` class. This is because the compiler can convert both `UP&lt;&gt;` objects to bool and these can be compared.
</code>cpp Auto conversion is bad (mostly)</p>

<pre><code>ThorsAnvil::UP&lt;int&gt;    value1(int(8));
ThorsAnvil::UP&lt;int&gt;    value2(int(9));

if (value1 == value2) {
    // unfortunately this will print "They match".
    // Because both values are converted to bool (in this case true).
    // Then the test is done.
    std::cout &lt;&lt; "They match\n";
}
</code></pre>

<p><code>
In C++03 there was a nasty work around using pointers to members. But in C++11 there was added new functionality to make the conversion operator only fire in a boolean context otherwise it must be explicitly called.
</code>cpp explicit converter</p>

<pre><code>    explicit operator bool() {return data;}
...
ThorsAnvil::UP&lt;int&gt;    value1(int(8));
ThorsAnvil::UP&lt;int&gt;    value2(int(9));

if (value1) { // This is expecting a boolean expression.
    std::cout &lt;&lt; "Not nullptr\n";
}

if (static_cast&lt;bool&gt;(value1) == static_cast&lt;bool&gt;(value2)) { // Need to be explicit
    std::cout &lt;&lt; "Both are either nullptr or not\n";
}
</code></pre>

<p>```</p>

<h2>Fixed First Try</h2>

<p>So given the problems described above we can update our implementation to compensate for these issues:
```cpp ThorsAnvil::UP Version 2</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*   data;
        public:
            // Explicit constructor
            explicit UP(T* data)
                : data(data)
            {}
            ~UP()
            {
                delete data;
            }
            // Remove compiler generated methods.
            UP(UP const&amp;)            = delete;
            UP&amp; operator=(UP const&amp;) = delete;

            // Const correct access owned object
            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}

            // Access to smart pointer state
            T* get()                 const {return data;}
            explicit operator bool() const {return data;}

            // Modify object state
            T* release()
            {
                T* result = nullptr;
                std::swap(result, data);
                return result;
            }
    };
}
</code></pre>

<p>```
If you are thinking this is not enough you are correct. We still have some more work to do. But lets leave it at that for version one.</p>

<h2>Summary</h2>

<p>So in this initial post we have looked at a typical first attempt at a smart pointer and summarized the common problems I often see in these home grown smart pointer implementations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Control Flow]]></title>
    <link href="http://lokiastari.com/blog/2013/12/02/so-you-want-to-learn-c-plus-plus-part-5/"/>
    <updated>2013-12-02T12:00:11-08:00</updated>
    <id>http://lokiastari.com/blog/2013/12/02/so-you-want-to-learn-c-plus-plus-part-5</id>
    <content type="html"><![CDATA[<p>So far we have demonstrated basic programs that just do a single task without making any decisions. Most (all but the most trivial) programming languages provide constructs for decision making (Conditional Branching).</p>

<p>C++ provides two forms of branching. The <strong>&ldquo;If Statement&rdquo;</strong> and the <strong>&ldquo;Switch Statement&rdquo;</strong> .</p>

<p>Note: Looping is also a form of branching. The looping concept is extensive enough that we will deal with looping separately in its own article.</p>

<h3>If Statement</h3>

<p>The <strong>&ldquo;If Statement&rdquo;</strong> allows code to be executed when a certain condition is fulfilled and optionally an alternative piece of code otherwise.
``` cpp ifstatement.cpp</p>

<pre><code>// First versin of "If Statement"
// Execute code if &lt;Condition&gt; is true.
//
if (&lt;Condition&gt;)
{
    &lt;code to execute if Condition is true&gt;
}


// Second version of "If Statement"
// Execute code1 if &lt;Condition&gt; is true or code2 if &lt;Condition&gt; is false 
//
if (&lt;Condition&gt;)
{
    &lt;code1: execute if Condition is true&gt;
}
else
{
    &lt;code2: execute if Condition is false&gt;
}
</code></pre>

<p>```</p>

<p>The standard comparison operators that you find in most languages can be used. These operators are defined for all the built-in types. On user defined types in the standard library they are defined in ways that makes their usage obvious. When you define these for your user defined types you should also make sure that they behave in the logical manner described below; the language does not enforce this, <strong>BUT</strong> if you don&rsquo;t follow this suggestion your types will scare people and they will not be used, so follow the expected behavior.</p>

<p><code>cpp Standard Comparison Operators
/*
| Operator  | Usage   | Result Type | Meaning                                                           |
| ----------|---------|-------------|-------------------------------------------------------------------|
|    !      |  !A     |  bool       | Not A. If A is true then false, if A is false then true.          |
|           |         |             | If A us not a bool type it is converted (see below)               |
|    ==     |  A == B |  bool       | true if A and B logically equivalent, otherwise false.            |
|    !=     |  A != B |  bool       | Should mean !(A == B)                                             |
|    &lt;      |  A &lt;  B |  bool       | true if A is logically less than B.                               |
|    &lt;=     |  A &lt;= B |  bool       | true if A is logically less than or equal to B.                   |
|    &gt;      |  A &gt;  B |  bool       | true if A is logically greater than B.                            |
|    &gt;=     |  a &gt;= B |  bool       | true if A is logically greater than or equal to B.                |
|    &amp;&amp;     |  A &amp;&amp; B |  bool       | true if A is true **AND** B is true.                              |
|           |         |             | If the expressions A or B are not actually bool then              |
|           |         |             | it is converted (see below). Also worth noting is that            |
|           |         |             | if A is **false** then the expression for B is not evaluated.     |
|           |         |             | This is known as a shortcut operator we will describe this later. |
|    ||     |  A || B |  bool       | true if A is true **OR** B is true.                               |
|           |         |             | If the expressions A or B are not actually a bool then            |
|           |         |             | it is converted (see below). Also worth noting is that            |
|           |         |             | if A is **true** then the expression for B is not evaluated.      |
|           |         |             | This is known as a shortcut operator we will describe this later. |
|-----------|---------|-------------|-------------------------------------------------------------------|
*/
</code></p>

<p>If the expression you use in **&lt;Condition&gt; does not actually result in a bool value the compiler will insert a conversion that will result in a bool (true/false) value. If no conversion is possible it results in a compile time error.</p>

<p><code>cpp Type conversion
/*
| Type             | false      | true            | Notes                                               |
|------------------|------------|-----------------|-----------------------------------------------------|
| bool             | false      | true            | Should be obvious: No actual conversion used.       |
| Integers         | 0          | (anything else) | Integer shorthand for (char/short/int/long)         |
| Pointers         | NULL       | (anything else) | Will discuss pointers in detail later.              |
| User Define Type | ?          | ?               | If a cast operator to bool/Integer/pointer exists   |
|                  |            |                 | this will be used.                                  |
|------------------|------------|-----------------|-----------------------------------------------------|
*/
</code></p>

<p>An example of using an <strong>If Statement</strong>:
``` cpp itest.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string    name;
    std::cout &lt;&lt; "Please enter your name\n";
    std::cin &gt;&gt; name;

    if (name == "Loki")
    {
        std::cout &lt;&lt; "Hello Admin\n";
    }
    else
    {
        std::cout &lt;&lt; "Hello Muggle\n";
    }

    int   value;
    std::cin &gt;&gt; value;
    std::cout &lt;&lt; "Please enter a non zero integer value\n";
    if (value) // integer value converted to bool
    {
        std::cout &lt;&lt; "You got it correct. Must use a non zero value.\n";
    }
}
</code></pre>

<p>```</p>

<h3>Switch Statement</h3>

<p>The <strong>&ldquo;Switch Statement&rdquo;</strong> is an alternative to the <strong>&ldquo;If Statement&rdquo;</strong>. Prefer the switch when you have lots of options derived from the same expression. Unlike other high level language C++ can only use <strong>Integer</strong> types in a switch statement; thus in all `Case &lt;Value&gt; the &lt;Value&gt; must be an integer <strong>literal</strong> value.</p>

<p>``` cpp switch.cpp</p>

<pre><code>switch(&lt;Test Expression&gt;)
{
    case &lt;value1&gt;:
    {
        &lt;code1&gt;
        break;
    }
    case &lt;value2&gt;:
    {
        &lt;code2&gt;
        break;
    }
    case &lt;value3&gt;:
    {
        &lt;code3&gt;
        break;
    }
    default:
    {
        &lt;code Default&gt;
        break
    }
}
//
//
// Equivalent "If Statement"

int test = &lt;Test Expression&gt;;
if (&lt;value1&gt; == test)
{
    &lt;code1&gt;
}
else
{
    if (&lt;value2&gt; == test)
    {
        &lt;code2&gt;
    }
    else
    {
        if (&lt;value3&gt; == test)
        {
            &lt;code3&gt;
        }
        else
        {
            &lt;code Default&gt;
        }
    }
}
</code></pre>

<p>```</p>

<p>If you use a non Integer expression in the switch statement the compiler will try and convert the value to an integer. If this is not possible it generates a compile time error.</p>

<p>``` cpp switch.cpp</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int  value;
    std::cout &lt;&lt; "Input a value between 0 and 5\n";
    std::cin &gt;&gt; value;

    switch(value)
    {
        case 0: {std::cout &lt;&lt; "You used zero\n";    break;}
        case 1: {std::cout &lt;&lt; "You used one\n";     break;}
        case 2: {std::cout &lt;&lt; "You used two\n";     break;}
        case 3: {std::cout &lt;&lt; "You used three\n";   break;}
        case 4: {std::cout &lt;&lt; "You used four\n";    break;}
        case 5: {std::cout &lt;&lt; "You used five\n";    break;}
        default: {std::cout &lt;&lt; "You failed to follow instructions\n";break;}
    }
}
</code></pre>

<p>```</p>

<p>Note I: The language does not require you to use a <strong>Break Statement</strong> in each block. <strong>BUT</strong> you should and compilers will warn you when you don&rsquo;t.<br/>
Note II: You should always use a <strong>Default Statement</strong> . If the value does not hit a value specified in a <strong>Case Statement</strong> then the <strong>Default Statement</strong> is used; If the <strong>Default Statement</strong> is not defined in this situation it results in undefined behavior. To avoid problems you should always define the <strong>Default Statement</strong>, even if all this does is generate an error. This will avoid maintenance issues down the road.</p>
]]></content>
  </entry>
  
</feed>
