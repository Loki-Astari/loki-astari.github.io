<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vector | Loki Astari]]></title>
  <link href="http://lokiastari.com/blog/categories/vector/atom.xml" rel="self"/>
  <link href="http://lokiastari.com/"/>
  <updated>2016-08-19T09:22:48-07:00</updated>
  <id>http://lokiastari.com/</id>
  <author>
    <name><![CDATA[Loki Astari]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vector - The Other Stuff]]></title>
    <link href="http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff/"/>
    <updated>2016-03-20T22:26:43-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/20/vector-the-other-stuff</id>
    <content type="html"><![CDATA[<p>So the C++ standard specifies a set of requirements for containers. Very few requirements are specified in terms of containers so adhering to these exactly is not required (unless you want to be considered for the standard). But they provide an insight into what can be done with them and if you support them will allow your container to be more easily used with some features of the language and standard library. I am not going to go over all of them here (that is left as an exercise for the reader), but I will go over the ones I would expect to see in a simple implementation (the kind you would see in a university project).</p>

<p>For details see the <a href="http://stackoverflow.com/a/4653479/14065">latest copy of the C++ standard</a>.</p>

<ul>
<li>23.2.1  General container requirements [container.requirements.general]</li>
<li>23.2.3  Sequence containers [sequence.reqmts]</li>
</ul>


<h4>Internal Types</h4>

<ul>
<li>value&#95;type</li>
<li>reference</li>
<li>const&#95;reference</li>
<li>iterator</li>
<li>const&#95;iterator</li>
<li>difference&#95;type</li>
<li>size&#95;type</li>
</ul>


<p>It is worth specifying the internal types defined here. As this allows you to abstract the implementation details of the container. This will allow you to change the implementation details without users having to change their implementation; as long as the changes still provide the same interface but the interface to reference/pointers/iterators are relatively trivial and well defined.</p>

<h4>Constructors</h4>

<p>In C++11 the <code>std::initializer_list&lt;T&gt;</code> was introduced. This allows a better list initialization syntax to be used with user defined types. Since this is usually defined in terms of the range based construction we should probably add both of these constructors.</p>

<ul>
<li>Vector(std::initializer&#95;list<T> const&amp; list)</li>
<li>Vector(I begin, I end)</li>
</ul>


<h4>Iterators</h4>

<ul>
<li>begin()</li>
<li>rbegin()</li>
<li>begin() const</li>
<li>rbegin() const</li>
<li>cbegin() const</li>
<li>crbegin() const</li>
<li>end()</li>
<li>rend()</li>
<li>end() const</li>
<li>cend() const</li>
<li>rend() const</li>
<li>crend() const</li>
</ul>


<p>The iterators are relatively easy to write. They also allow the container to be used with the new range based for that was added in C++14. So this becomes another easy add.</p>

<h4>Member Access</h4>

<ul>
<li>at(&lt;index&gt;)</li>
<li>at(&lt;index&gt;) const</li>
<li>operator&#91;&#93;(&lt;index&gt;)</li>
<li>operator&#91;&#93;(&lt;index&gt;) const</li>
<li>front()</li>
<li>back()</li>
<li>front() const</li>
<li>back() const</li>
</ul>


<p>Member access to a vector should be very efficient. As a result normally range checks are not performed on member access, i.e. the user is expected to make sure that the method preconditions have been met before calling the method. This results in very efficient access to the members of a <code>Vector</code>. This is not normally a problem because index ranges are normally checked as part of a loop range as long as these are validated against the size of the array it does not need to be validated again.</p>

<p>```cpp For Loop Vector Access</p>

<pre><code>Vector&lt;T&gt;   d = getData();
for(int loop = 0; loop &lt; d.size(); ++loop)
{
    std::cout &lt;&lt; d[loop];   // No need for antoher range
                            // check here as we know that loop is inside the
                            // bounds of the vector d.
}
</code></pre>

<p>```</p>

<p>There is also the <code>at()</code> method which does validate the index provided before accessing the element (throwing an exception if the index is out of range).</p>

<h4>Non-Mutating Member Functions</h4>

<ul>
<li>size() const</li>
<li>bool() const</li>
</ul>


<p>To allow us to check the preconditions on the element access methods we need some functions that check the state of the object. These are provided here.</p>

<h4>Mutating Member Functions</h4>

<ul>
<li>push&#95;back(&lt;object-ref&gt;)</li>
<li>push&#95;back(&lt;object-rvalue-ref&gt;)</li>
<li>emplace&#95;back(&lt;args&hellip;&gt;)</li>
<li>pop&#95;back()</li>
</ul>


<p>The following members are standard easy to implement methods of <code>std::vector</code> (O(1)) that I would expect to see in every implementation.</p>

<p>The other mutating member functions are less trivial as they require elements to be moved around. They are not that hard but you must put some thought into the most efficient techniques to move elements (i.e. move or copy) and make sure that capacity is not exceeded by multiple inserts. As a result I would expect to see these methods only on an as needed basis.</p>

<h4>Comparators</h4>

<ul>
<li>operator== const</li>
<li>operator!= const</li>
</ul>


<p>Easy comparison operators.
Optionally you can provide the other comparison operators.</p>

<h1>Final</h1>

<p><strong>No idea why Jackal is adding all the blank lines to my source</strong>
```cpp Vector</p>

<h1>include &lt;type_traits></h1>

<h1>include <memory></h1>

<h1>include <algorithm></h1>

<h1>include <stdexcept></h1>

<h1>include <iterator></h1>

<p>template<typename T>
class Vector</p>

<pre><code>public:
    using value_type        = T;
    using reference         = T&amp;;
    using const_reference   = T const&amp;;
    using pointer           = T*;
    using const_pointer     = T const*;
    using iterator          = T*;
    using const_iterator    = T const*;
    using riterator         = std::reverse_iterator&lt;iterator&gt;;
    using const_riterator   = std::reverse_iterator&lt;const_iterator&gt;;
    using difference_type   = std::ptrdiff_t;
    using size_type         = std::size_t;

private:
    size_type       capacity;
    size_type       length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    template&lt;typename I&gt;
    Vector(I begin, I end)
        : capacity(std::distance(begin, end))
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        for(auto loop = begin;loop != end; ++loop)
        {
            pushBackInternal(*loop);
        }
    }
    Vector(std::initializer_list&lt;T&gt; const&amp; list)
        : Vector(std::begin(list), std::end(list))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            clearElements&lt;T&gt;();

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        copyAssign&lt;T&gt;(copy);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }

    // Non-Mutating functions
    size_type           size() const                        {return length;}
    bool                empty() const                       {return length == 0;}

    // Validated element access
    reference           at(size_type index)                 {validateIndex(index);return buffer[index];}
    const_reference     at(size_type index) const           {validateIndex(index);return buffer[index];}

    // Non-Validated element access
    reference           operator[](size_type index)         {return buffer[index];}
    const_reference     operator[](size_type index) const   {return buffer[index];}
    reference           front()                             {return buffer[0];}
    const_reference     front() const                       {return buffer[0];}
    reference           back()                              {return buffer[length - 1];}
    const_reference     back() const                        {return buffer[length - 1];}

    // Iterators
    iterator            begin()                             {return buffer;}
    riterator           rbegin()                            {return riterator(end());}
    const_iterator      begin() const                       {return buffer;}
    const_riterator     rbegin() const                      {return const_riterator(end());}

    iterator            end()                               {return buffer + length;}
    riterator           rend()                              {return riterator(begin());}
    const_iterator      end() const                         {return buffer + length;}
    const_riterator     rend() const                        {return const_riterator(begin());}

    const_iterator      cbegin() const                      {return begin();}
    const_riterator     crbegin() const                     {return rbegin();}
    const_iterator      cend() const                        {return end();}
    const_riterator     crend() const                       {return rend();}

    // Comparison
    bool operator!=(Vector const&amp; rhs) const {return !(*this == rhs);}
    bool operator==(Vector const&amp; rhs) const
    {
        return  (size() == rhs.size())
            &amp;&amp;  std::equal(begin(), end(), rhs.begin());
    }

    // Mutating functions
    void push_back(value_type const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void push_back(value_type&amp;&amp; value)
    {
        resizeIfRequire();
        moveBackInternal(std::move&lt;T&gt;(value));
    }
    template&lt;typename... Args&gt;
    void emplace_back(Args&amp;&amp;... args)
    {
        resizeIfRequire();
        emplaceBackInternal(std::move&lt;T&gt;(args)...);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(size_type capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void validateIndex(size_type index) const
    {
        if (index &gt;= length)
        {
            throw std::out_of_range("Out of Range");
        }
    }

    void resizeIfRequire()
    {
        if (length == capacity)
        {
            size_type     newCapacity  = std::max(2.0, capacity * 1.5);
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(size_type newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }

    // Add new element to the end using placement new
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }
    template&lt;typename... Args&gt;
    void emplaceBackInternal(Args&amp;&amp;... args)
    {
        new (buffer + length) T(std::move&lt;Args&gt;(args)...);
        ++length;
    }

    // Optimizations that use SFINAE to only instantiate one
    // of two versions of a function.
    //      simpleCopy()        Moves when no exceptions are guaranteed, otherwise copies.
    //      clearElements()     When no destructor remove loop.
    //      copyAssign()        Avoid resource allocation when no exceptions guaranteed.
    //                          ie. When copying integers reuse the buffer if we can
    //                          to avoid expensive resource allocation.

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }
    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }


    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be reused without using the destructor.
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                        &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // This function is only used if there is no chance of an exception being
        // thrown during destruction or copy construction of the type T.


        // Quick return for self assignment.
        if (this == &amp;copy)
        {
            return;
        }

        if (capacity &lt;= copy.length)
        {
            // If we have enough space to copy then reuse the space we currently
            // have to avoid the need to perform an expensive resource allocation.

            clearElements&lt;T&gt;();     // Potentially does nothing (see above)
                                    // But if required will call the destructor of
                                    // all elements.

            // buffer now ready to get a copy of the data.
            length = 0;
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                pushBackInternal(copy[loop]);
            }
        }
        else
        {
            // Fallback to copy and swap if we need to more space anyway
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                         &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
    copyAssign(Vector&lt;X&gt;&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
    }
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Simple Optimizations]]></title>
    <link href="http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations/"/>
    <updated>2016-03-19T15:06:40-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations</id>
    <content type="html"><![CDATA[<p>So now that we have used <code>std::is_nothrow_move_constructible</code> we can also look at a couple of other types available in the template utility library.</p>

<h1>Optimized Destruction</h1>

<p>Since we have to manually call the destructor on all objects in the container (because we are using placement new) we can look to see if we can optimize that. The type <code>std::is_trivially_destructible</code> detects if the type is <strong>Trivially</strong> destructible. This basically means that there will be no side effects from the destructor (See: Section 12.4 Paragraph 5 of the standard). For types we don&rsquo;t need to call the destructor of the object. For the <code>Vector</code> class this means we can eliminate the call to the destructor but more importantly the loop.</p>

<p>```cpp Destroying Elements</p>

<pre><code>    ~Vector()
    {
        // STUFF..

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            throw;
        }
    }
</code></pre>

<p>```</p>

<p>We can use the same SFINAE technique that we used in the previous article to remove the loops when the contained type is trivially destructible.</p>

<p>```</p>

<pre><code>    ~Vector()
    {
        // STUFF..
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            clearElements&lt;T&gt;();
            throw;
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be re-used without using the destructor.
    }
</code></pre>

<p>```</p>

<h1>Optimized Assignment Operator</h1>

<p>The final optimization is because resource allocation is expensive. So if we can avoid the resource allocation completely and just reuse the space we currently have.</p>

<p>```cpp Copy Assignment</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
</code></pre>

<p>```</p>

<p>The copy and swap idiom is perfect for providing the strong exception guarantee in the presence of exceptions. <strong>But</strong> if there are no exceptions during destruction or construction then we can potentially just reuse the available memory. So if we rewrote the assignment operator with the assumption that there were no exceptions it would look like the following (Note in the real code use SFINAE to do the optimization only when necessary).</p>

<p>```cpp Copy the easy way</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Check for self assignment
        // As we are doing work anyway.
        if (this == &amp;copy)
        {
            return *this;
        }

        // If the length of the `copy` object exceeds
        // the capacity of the current object then
        // we have to do resource management. It costs
        // nothing extra to use the copy and swap idiom
        if (copy.length &gt; capacity)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
            return *this;
        }

        // The optimization happens here.
        // We can reuse the buffer we already have.
        clearElements&lt;T&gt;();     // use clearElements() as it probably does very little.
        length = 0;

        // Now add the elements to this container as cheaply as possible.
        for(int loop = 0; loop &lt; copy.length; ++loop)
        {
            pushBackInternal(copy[loop]);
        }
        return *this;
    }
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-4"></a></h1>

<p>The final version</p>

<p>```cpp Vector Final Version</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    std::size_t     capacity;
    std::size_t     length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

    public:
        Vector(int capacity = 10)
            : capacity(capacity)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {}
        ~Vector()
        {
            // Make sure the buffer is deleted even with exceptions
            // This will be called to release the pointer at the end
            // of scope.
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

            clearElements&lt;T&gt;();
        }
        Vector(Vector const&amp; copy)
            : capacity(copy.length)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {
            try
            {
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    push_back(copy.buffer[loop]);
                }
            }
            catch(...)
            {
                std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
                clearElements&lt;T&gt;();

                // Make sure the exceptions continue propagating after
                // the cleanup has completed.
                throw;
            }
        }
        Vector&amp; operator=(Vector const&amp; copy)
        {
            copyAssign&lt;T&gt;(copy);
            return *this;
        }
        Vector(Vector&amp;&amp; move) noexcept
            : capacity(0)
            , length(0)
            , buffer(nullptr)
        {
            move.swap(*this);
        }
        Vector&amp; operator=(Vector&amp;&amp; move) noexcept
        {
            move.swap(*this);
            return *this;
        }
        void swap(Vector&amp; other) noexcept
        {
            using std::swap;
            swap(capacity,      other.capacity);
            swap(length,        other.length);
            swap(buffer,        other.buffer);
        }
        void push_back(T const&amp; value)
        {
            resizeIfRequire();
            pushBackInternal(value);
        }
        void pop_back()
        {
            --length;
            buffer[length].~T();
        }
        void reserve(std::size_t capacityUpperBound)
        {
            if (capacityUpperBound &gt; capacity)
            {
                reserveCapacity(capacityUpperBound);
            }
        }
    private:
        void resizeIfRequire()
        {
            if (length == capacity)
            {
                std::size_t     newCapacity  = std::max(2.0, capacity * 1.5);
                reserveCapacity(newCapacity);
            }
        }
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            simpleCopy&lt;T&gt;(tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
        clearElements()
        {
            // Call the destructor on all the members in reverse order
            for(int loop = 0; loop &lt; length; ++loop)
            {
                // Note we destroy the elements in reverse order.
                buffer[length - 1 - loop].~T();
            }
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
        clearElements()
        {
            // Trivially destructible objects can be reused without using the destructor.
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == true&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            if (this == &amp;copy)
            {
                return;
            }

            if (capacity &lt;= copy.length)
            {
                clearElements&lt;T&gt;();
                length = 0;
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    pushBackInternal(copy[loop]);
                }
            }
            else
            {
                // Copy and Swap idiom
                Vector&lt;T&gt;  tmp(copy);
                tmp.swap(*this);
            }
        }
        template&lt;typename X&gt;
        typename std::enable_if&lt;(std::is_nothrow_copy_constructible&lt;X&gt;::value
                             &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value) == false&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
};
</code></pre>

<p>```</p>

<h1>Summary</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Resize]]></title>
    <link href="http://lokiastari.com/blog/2016/03/12/vector-resize/"/>
    <updated>2016-03-12T04:53:07-08:00</updated>
    <id>http://lokiastari.com/blog/2016/03/12/vector-resize</id>
    <content type="html"><![CDATA[<p>Because resizing a vector is expensive; the <code>std::vector</code> class uses exponential growth to minimize the number of times that the vector is resized: a technique we replicate in this version. But every now and then you still need to resize the internal buffer.</p>

<p>In the <a href="#VectorVersion-1">current version</a>, resizing the vector requires allocating a new buffer and copying all the members into it. Basically we are using the copy and swap idiom to provide the strong exception guarantee (If an exception is thrown all resources are cleaned up and the object remains unchanged).
```cpp Vector Resize with Copy</p>

<pre><code>    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T const&amp; v){tmpBuffer.pushBackInternal(v);}
                     );

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>```</p>

<h1>Resize With Move Construction</h1>

<p>Thus resizing a <code>Vector</code> can be a very expensive operation because of all the copying that can happen.</p>

<p>Using the move constructor rather than the copy constructor during a resize operation could potentially be much more efficient. But the move constructor mutates the original object and thus if there is a problem we need to undo the mutations to maintain the strong exception guarantee.</p>

<p>The first attempt at this is:
```cpp Vector Resize with Move With Exceptions</p>

<pre><code>    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        try
        {
            std::for_each(buffer, buffer + length,
                          [&amp;tmpBuffer](T&amp; v){tmpBuffer.moveBackInternal(std::move(v));}
                         );
        }
        catch(...)
        {
            // If an exception is thrown you need to move the objects back
            // from the temporary buffer back to this object.
            for(int loop=0; loop &lt; tmpBuffer.length; ++loop)
            {
                // The problem is here:
                // If the initial move can throw,
                // then trying to move any of the objects back can also throw.
                // which would leave the object in an inconsistent state.
                buffer[loop] = std::move(tmpBuffer[loop]);
            }

            // Then remember to rethrow the exception after we have fixed the state.
            throw;
        }

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>```</p>

<h1>Resize With NoThrow Move Construction</h1>

<p>As the above code shows; if the type <code>T</code> can throw during its move constructor then you can&rsquo;t guarantee that the object gets returned to the original state (as moving the already moved elements back may cause another exception). So we cannot use the move constructor to resize the vector if the type <code>T</code> can throw during move construction.</p>

<p>But not all types throw when being moved. In fact it is recommended that move constructors never throw. If we can guarantee that the move constructor does not throw then we can simplify the above code considerably and still provide the strong exception guarantee.
```cpp Vector Resize with Move</p>

<pre><code>    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T&amp; v){tmpBuffer.moveBackInternal(std::move(v));}
                     );

        tmpBuffer.swap(*this);
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }
</code></pre>

<p>```</p>

<h1>Resize Template Specialization</h1>

<p>So now we have to write the code that decides at compile time which version we should use. The simplest way to do this is to use template specialization of a class using the standard class <code>std::is_nothrow_move_constructible&lt;T&gt;</code> to help differentiate types that have a non-throwing move constructor. This is simple enough:
```cpp Template class Specialization</p>

<pre><code>template&lt;typename T, bool = std::is_nothrow_move_constructible&lt;T&gt;::value&gt;
struct SimpleCopy
{
    // Define two different versions of this class.
    // The object is to copy all the elements from src to dst Vector
    // using pushBackInternal or moveBackInternal
    //
    // SimpleCopy&lt;T, false&gt;:        Defines a version that use pushBackInternal (copy constructor)
    //                              This is always safe to use.
    // SimpleCopy&lt;T, true&gt;:         Defines a version that uses moveBackInternal (move constructor)
    //                              Safe when move construction does not throw.
    //
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const;
};
template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        // We are using private methods for effeciency.
        // So these classes need to be friends.
        friend struct SimpleCopy&lt;T, true&gt;;
        friend struct SimpleCopy&lt;T, false&gt;;

        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            // Create the copier object base on the type T.
            // Note: The second parameter is automatically generated based
            //       on if the type T is move constructable with no exception.
            SimpleCopy&lt;T&gt;   copier;
            copier(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }
}
// Define the two different types of copier
template&lt;typename T&gt;
struct SimpleCopy&lt;T, false&gt; // false: does not have nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }
};
template&lt;typename T&gt;
struct SimpleCopy&lt;T, true&gt; // true: has a nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }
};
</code></pre>

<p>```</p>

<h1>Resize With NoThrow SFINAE</h1>

<p>The above technique has a couple of issues.</p>

<p>The type <code>SimpleClass</code> is publicly available and is a friend of <code>Vector&lt;T&gt;</code>. This makes it susceptible to accidentally being used (even if not explicitly documented). Unfortunately it can&rsquo;t be included as a member class and also be specialized.</p>

<p>Additionally it looks awful!!</p>

<p>But we can also use <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> and method overloading.</p>

<p>SFINAE allows us to define several versions of a method with exactly the same arguments, as long as only one of them is valid at compile time. So in the example below we define two versions of the method <code>SimpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)</code> but then use <code>std::enable_if</code> to make sure only one version of the function is valid at compile time.</p>

<p>```cpp SFINAE method overload</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            SimpleCopy&lt;T&gt;(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void pushBackInternal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void moveBackInternal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::move(value));
            ++length;
        }

        template&lt;typename X&gt;
        // Note: this defines the return type of the function.
        //       But only one has a valid member `type` thus only
        //       one of the following functions is actually valid.
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                         );
        }
}
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-3"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = std::max(2.0, capacity * 1.5);
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void moveBackInternal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::move(value));
        ++length;
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.pushBackInternal(v);}
                     );
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.moveBackInternal(std::move(v));}
                     );
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of resizing the internal buffer. We have covered a couple of techniques on the way:</p>

<ul>
<li>Move Constructor Concepts</li>
<li>Template Class Specialization</li>
<li>SFINAE</li>
<li>std::is_nothrow_move_constructible&lt;&gt;</li>
<li>std::enable_if&lt;&gt;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Resource Management Copy Swap]]></title>
    <link href="http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment/"/>
    <updated>2016-02-29T12:29:20-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment</id>
    <content type="html"><![CDATA[<p>In the previous article I went over basic allocation for a <code>Vector</code> like class. In this article I want to put some detail around the copy assignment operator and resizing the underlying <code>Vector</code>. Unlike the other methods previously discussed these methods have to deal with both construction and destruction of elements and the potential of exceptions interrupting the processes. The goal is to provide exception safe methods that provide the strong exception guarantee for the object and do not leak resources.</p>

<h1>Copy Assignment</h1>

<h2>First Try</h2>

<p>This is a very common first attempt at a copy constructor.
It simply calls the destructor on all elements currently in the object. Then uses the existing <code>push_back()</code> method to copy member elements from the source object, thus allowing the object to automatically resize if required.</p>

<p>```cpp Copy Assignment (Try 1)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // First we have to destroy all the current elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Destroy in reverse order
        buffer[length - 1 - loop].~T();
    }
    // Now the buffer is empty so reset size to zero.
    length = 0;

    // Now copy all the elements from the source into this object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Strong Exception Guarantee</h2>

<p>The obvious problems about efficiency when a resize is required is a minor issue here. The real problem is that this does not provide the strong exception guarantee. If any of the constructors/destructor throw then the object will be left in an inconsistent state with no way to restore the original state. The strong exception guarantee basically means that the operation works or does not change the state of the object. The easiest technique to achieve this is to create a copy in a new temporary buffer that can be thrown away if things go wrong (leaving the current object untouched). If the copy succeeds then we use it and throw away the original data.</p>

<p>```cpp Copy Assignment (Try 2)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy of the src object.
    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }

    // Part-2 Swap the state
    // We have successfully created the new version of this object
    // So swap the temporary and object states.
    std::swap(tmpCap,    capacity);
    std::swap(tmpSize,   length);
    std::swap(tmpBuffer, buffer);

    // Part-3 Destroy the old state.
    // Now we have to delete the old state.
    // If this fails it does not matter the state of the object is consistent
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Copy and Swap</h2>

<p>This second attempt is a better attempt. But it still leaks if an exception is throw. But before we add exception handling, let us take a closer look at the three sections of the assignment operator.</p>

<p>Part-1 looks exactly like the copy constructor of Vector.</p>

<p>```cpp Copy Assignment Part 1</p>

<pre><code>    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        // This looks exactly like push_back()
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }
</code></pre>

<p>```</p>

<p>Part-3 looks exactly like destructor of Vector.
```cpp Copy Assignment Part 3</p>

<pre><code>    // Now we have to delete the old state.
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
</code></pre>

<p>```</p>

<p>Using these two observations we have a rewrite of the copy assignment operator.</p>

<p>```cpp Copy Assignment (Try 3)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy
    Vector  tmp(copy);

    // Part-2 Swap the state
    std::swap(tmp.capacity, capacity);
    std::swap(tmp.length,   length);
    std::swap(tmp.buffer,   buffer);

    return *this;
    // Part-3 Destructor called at end of scope.
    // No actual code required here.
}
</code></pre>

<p>};
```</p>

<h2><a href="http://stackoverflow.com/q/3279543/14065">Copy And Swap Idiom</a></h2>

<p>The copy and swap idiom is about dealing with replacing an object state from another object. It is very commonly used in the copy assignment operator but has application whenever state is being changed and the <a href="https://en.wikipedia.org/wiki/Exception_safety">strong exception guarantee</a> is required.</p>

<p>The above code works perfectly. But in Part-2 the swap looks like a normal swap operation so let&rsquo;s use that rather than doing it manually. Also self assignment now works without the need for a test (because we are copying into a temporary). So we can remove the check for self assignment. Yes this does make the performance for self assignment worse, but it makes the normal operation even more efficient. Since the occurrence of self assignment is extremely rare I would not prematurely optimize for it but rather make the most common case the best optimized. So one final re-factor of the copy constructor leaves us with this.</p>

<p>```cpp Copy Assignment (Try 4)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    Vector  tmp(copy);
    tmp.swap(*this);
    return *this;
}
void swap(Vector&amp; other) noexcept
{
    std::swap(other.capacity, capacity);
    std::swap(other.length,   length);
    std::swap(other.buffer,   buffer);
}
</code></pre>

<p>};
```</p>

<h1>Resizing Underlying buffer</h1>

<p>When pushing data into the array we need to verify that capacity has not been exceeded. If it has then we need to allocate more capacity then copy the current content into the new buffer and destroy the old buffer after calling the destructor on all elements.</p>

<h2>Using Copy and Swap</h2>

<p>This operation is exceedingly similar to the description of the copy assignment operator. As a result the best solution looks very similar and uses the Copy and Swap idiom.</p>

<p>```cpp Vector Reallocating Buffer
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
void resizeIfRequire()
{
    if (length == capacity)
    {
        // Create a temporary object with a larger capacity.
        std::size_t     newCapacity  = std::max(2.0, capacity * 1.5);
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        // Copy the state of this object into the new object.
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; item){tmpBuffer.push_back(item);});

        // All the work has been successfully done. So swap
        // the state of the temporary and the current object.
        tmpBuffer.swap(*this);

        // The temporary object goes out of scope here and
        // tidies up the state that is no longer needed.
    }
}
</code></pre>

<p>};
```</p>

<h1>Final Version <a id="VectorVersion-2"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        pushBackInternal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = std::max(2.0, capacity * 1.5);
            reserveCapacity(newCapacity);
        }
    }
    void pushBackInternal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; v){tmpBuffer.pushBackInternal(v);});

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of the Copy and Swap idiom and shown how it is used in the Copy Assignment Operator and the resize operation.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Copy and Swap Idiom</li>
<li>Exception Gurantees</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Resource Management Allocation]]></title>
    <link href="http://lokiastari.com/blog/2016/02/27/vector/"/>
    <updated>2016-02-27T12:00:31-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/27/vector</id>
    <content type="html"><![CDATA[<p>A lot of new developers to C++ attempt to build a <code>Vector</code> like container as a learning processes. Getting a simple version of this working for POD types (like int) is not that complicated. The next step in getting this working for arbitrary data types takes a significant leap forward in thinking in C++ especially when you start looking at efficiency and exception safety. This set of five articles looks at building an efficient <code>Vector</code> implementation. I show some of the common mistakes and explain why and how to resolve the problems:</p>

<p>Note: This is not meant to replace <code>std::vector&lt;&gt;</code> this is simply meant as a teaching process.</p>

<h1>Rule of Zero</h1>

<p>You will notice that half the attempts below <a href="#Sources">Sources</a> are Vector implementations the other half are for Matrix implementations. I mention both because I want to emphasize the <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>. An object should be responsible for either business logic or resource management (not both). A lot of the Matrix implementations are trying to mix resource management (memory management) with the business logic of how matrices interact. So if you want to write a matrix class you should delegate resource management to a separate class (In a first pass <code>std::vector&lt;int&gt;</code> would be a good choice).</p>

<p>In C++ the compiler generates a couple of methods for free.</p>

<ul>
<li>Destructor</li>
<li>Copy Constructor</li>
<li>Copy Assignment Operator</li>
<li>Move Constructor</li>
<li>Move Assignment Operator</li>
</ul>


<p>These methods usually work perfectly well; <strong>unless</strong> your class contains a pointer (or a pointer like resource object). But if your class is doing business logic then it should not contain a pointer. So classes that handle business logic therefore should not be defining any of these compiler generated methods (just let the compiler generated ones work for you). Occasionally you want to delete them, to prevent copying or movement, but it is very unusual for these to need specialized implementations.</p>

<p>Conversely, classes that do resource management usually contain a pointer (or pointer like resource object). These classes should define all the above methods to correctly handle the resource. This is where ownership semantics of the resource are defined. The owner of the resource is responsible for destroying the resource when its lifespan is over (in terms of pointers this means the owner is responsible for calling <code>delete</code> on the pointer, usually in the destructor). If you are not the owner of a resource you should not have access to the resource object directly, as it may be destroyed by the owner without other objects knowing.</p>

<h1><a href="http://stackoverflow.com/q/4172722/14065">Rule of three</a></h1>

<p>The rule of three comes from C++03 where we only had copy semantics.</p>

<h2>Version-1 Simple Resource Management</h2>

<p>When creating a class to manage resources; the first version created by beginner usually looks like this:</p>

<p>```cpp Rule of three first pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])   // Allocate the resource
{}
~Vector()
{
    delete [] buffer;       // Clean up the resource
}
</code></pre>

<p>};
```
The trouble here is that this version has a fundamental flaw because of the way the <a href="http://stackoverflow.com/a/4044360/14065">compiler generated</a> copy constructor and copy assignment operator work with pointers (commonly referred to as the <a href="http://stackoverflow.com/q/2344664/14065">shallow copy problem</a>).</p>

<p>```cpp Shallow copy problem.
int main()
{</p>

<pre><code>Vector&lt;int&gt;   x;
Vector&lt;int&gt;   y(x);     // Compiler generate copy constructure does
                        // an element wise shallow copy of each element.
                        // This means both `x` and `y` have a buffer
                        // member that points at the same area in memory.
                        //
                        // When the objects go out of scope both will
                        // try and call delete on the memory resulting
                        // in a double delete of the memory.

Vector&lt;int&gt;   z;        // Same problem after an assignment.
z=x;
</code></pre>

<p>}
```</p>

<h2>Version-2 Rule of Three</h2>

<p>The rule of three simply stated is: If you define any of the methods Destructor/Copy Constructor/Copy Assignment Operator then you should define all three. When done correctly this resolves the shallow copy problem. <code>Vector</code> defines the destructor so we also need to define the copy constructor and copy assignment operator.</p>

<p>I see this as an initial attempt at defining the rule of three for vectors very often.</p>

<p>```cpp Rule of three second pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])
{}
~Vector()
{
    delete [] buffer;
}
Vector(Vector const&amp; copy)
    : size(copy.size)
    , buffer(new T[size])
{
    // Copy constructor is simple.
    // We create a new resource area of the required size.
    // Then we copy the data from the old buffer to the new buffer.
    std::copy(copy.buffer, copy.buffer + copy.size, buffer);
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Version-3 Lazy Construction of elements.</h2>

<p>The problem with the previous version is that it forces initialization of all elements in the buffer immediately. This forces the requirement that members of the <code>Vector</code> (i.e. type <code>T</code>) must be default constructable. It also has two efficiency constraints imposed on the Vector:</p>

<ul>
<li>You can&rsquo;t pre-allocate space for future members.

<ul>
<li>So resizing (larger or smaller) becomes very expensive as each resize requires copy all the elements to the newly re-sized buffer.</li>
<li>Alternatively pre-creating all the elements you need can also be expensive especially if construction of <code>T</code> is expensive.</li>
</ul>
</li>
<li>The copy constructor is twice as expensive as it should be. Each element must be:

<ul>
<li>Default constructed (when the buffer is created).</li>
<li>Then copy constructed with the value from the source vector.</li>
</ul>
</li>
</ul>


<p>This attempt improves on that by allowing efficient pre-allocating of space (<code>capacity</code>) for the buffer. New members are then added by constructing in-place using <a href="http://stackoverflow.com/questions/362953/what-are-uses-of-the-c-construct-placement-new">placement new</a>.</p>

<p>```cpp Rule of three third pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
Vector(int capacity)
    : capacity(capacity = 100)
    , length(0)
    // Allocates space but does not call the constructor
    , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    // Useful if the type T has an expensive constructor
    // We preallocate space without initializing it giving
    // room to grow and shrink the buffer without re-allocating.
{}
~Vector()
{
    // Because elements are constructed in-place using
    // placement new. Then we must manually call the destructor
    // on the elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Note we destroy the elements in reverse order.
        buffer[length - 1 - loop].~T();
    }
    ::operator delete(buffer);
}
Vector(Vector const&amp; copy)
    : capacity(copy.length)
    , length(0)
    , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
{
    // Copy constructor is simple.
    // We create a new resource area of the required length.
    // But these elements are not initialized so we use push_back to copy them
    // into the new object. This is an improvement because we
    // only construct the members of the vector once.
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
void push_back(T const&amp; value)
{
    // Use placement new to copy buffer into the new buffer
    new (buffer + length) T(value);
    ++length;

    // Note we will handle growing the capacity later.
}
void pop_back()
{
    // When removing elements need to manually call the destructor
    // because we created them using placement new.
    --length;
    buffer[length].~T();
}
</code></pre>

<p>};
```</p>

<h1>Rule of Five</h1>

<p>In C++11 the language added the concept of &ldquo;Move Semantics&rdquo;. Rather than having to copy an object (especially on return from a function) we could &ldquo;move&rdquo; an object. The concept here is that movement is supposed to be much cheaper than copying because you move the internal data structure of an object rather than all the elements. A good example is a std::vector. Before C++11 a return by value meant copying the object. The constructor of the new object allocates a new internal buffer and then copies all the elements from the original object&rsquo;s buffer to the new object&rsquo;s buffer. On the other hand a move simply gives the new object the internal buffer of the old object (we just move the pointer to the internal buffer). When an object is moved to another object the old object should be left in a valid state, but for efficiency the standard rarely specifies the state of an object after it has been the source of a move. Thus using an object after a move is a bad idea unless you are setting it to a specific state.</p>

<p>There are two new methods that allow us to specify move semantics on a class.</p>

<p>```cpp Vector Move Semantics.
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept;

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept;
</code></pre>

<p>};
```</p>

<p>Notice the <code>&amp;&amp;</code> operator. This donates an r-value reference and means that your object is the destination of a move operation. The parameter passed is the source object and the state you should use to define your new object&rsquo;s state. After the move the source object must be left in a valid (but can be undefined state). For a vector this means it must no longer be the owner of the internal buffer that you are now using in your buffer.</p>

<p>The simplest way to achieve this goal is to set up the object in a valid (but very cheap to achieve state) and then swap the current object with the destination object.</p>

<p>```cpp Vector Move Semantics Implementation
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept
    : capacity(0)
    , length(0)
    , buffer(nullptr)
{
    // The source object now has a nullptr/
    // This object has taken the state of the source object.
    move.swap(*this);
}

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept
{
    // In this case simply swap the source object
    // and this object around.
    move.swap(*this);
    return *this;
}
</code></pre>

<p>};
```</p>

<p>Note I marked both move operators <code>noexcept</code>. Assuming the operations are guaranteed not to throw you should mark them as <code>noexcept</code>. If we know that certain operations are exception safe, then we can optimize resize operations and maintain the strong exception guarantee. This and some other optimizations will be documented in a subsequent post.</p>

<h1>Final Version <a id="VectorVersion-1"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Covered in Part 2
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        new (buffer + length) T(value);
        ++length;
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            // Covered in Part 2
        }
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has shown how to handle the basic resource management required by a vector. It has covered several important principles for C++ programmers.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Rule of Zero</li>
<li>Rule of Three</li>
<li>Rule of Five</li>
<li>Default compiler generated methods</li>
<li>Shallow Copy Problem</li>
<li>Placement New</li>
<li>Exception Guarantees</li>
</ul>


<h1>Sources  <a id="Sources"></a></h1>

<p>Looking at <a href="http://CodeReview.stackexchange.com">CodeReview.stackexchange.com</a>; reimplementing the vector class is a common goal for a first project.</p>

<ul>
<li>2011/Nov/07 &ndash; <a href="http://codereview.stackexchange.com/q/5856/507">Mathematical Vector2 class implementation</a>*</li>
<li>2012/May/21 &ndash; <a href="http://codereview.stackexchange.com/q/11934/507">C++ Vector2 Class Review</a>*</li>
<li>2012/Aug/17 &ndash; <a href="http://codereview.stackexchange.com/q/14784/507">Templated Matrix class</a></li>
<li>2013/Jan/07 &ndash; <a href="http://codereview.stackexchange.com/q/20243/507">Vector implementation &ndash; simple replacement</a></li>
<li>2013/May/25 &ndash; <a href="http://codereview.stackexchange.com/q/26608/507">Review of 2d Vector class</a></li>
<li>2013/Jun/19 &ndash; <a href="http://codereview.stackexchange.com/q/27573/507">Simple matrix class</a></li>
<li>2013/Jun/21 &ndash; <a href="http://codereview.stackexchange.com/q/27625/507">Matrix and Vector4 classes</a>*</li>
<li>2013/Jun/25 &ndash; <a href="http://codereview.stackexchange.com/q/27752/507">Simple matrix class &ndash; version 2</a>*</li>
<li>2013/Aug/03 &ndash; <a href="http://codereview.stackexchange.com/q/29331/507">Template vector class</a>*</li>
<li>2014/Feb/20 &ndash; <a href="http://codereview.stackexchange.com/q/42297/507">C++ vector implementation</a></li>
<li>2014/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/43136/507">Reimplementation of C++ vector</a></li>
<li>2014/Mar/12 &ndash; <a href="http://codereview.stackexchange.com/q/44167/507">3D mathematical vector class</a></li>
<li>2014/May/17 &ndash; <a href="http://codereview.stackexchange.com/q/50975/507">Creating a custom Vector class</a></li>
<li>2014/Aug/19 &ndash; <a href="http://codereview.stackexchange.com/q/60484/507">STL vector implementation</a></li>
<li>2014/Sep/12 &ndash; <a href="http://codereview.stackexchange.com/a/62774/507">C++ 3D Vector Implementation</a></li>
<li>2014/Sep/26 &ndash; <a href="http://codereview.stackexchange.com/q/63970/507">Custom mathematical vector class</a></li>
<li>2014/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/67209/507">Vector backed by memory pages</a></li>
<li>2014/Oct/31 &ndash; <a href="http://codereview.stackexchange.com/q/68486/507">Custom matrix class</a></li>
<li>2014/Nov/25 &ndash; <a href="http://codereview.stackexchange.com/q/70815/507">Vector/matrix class</a></li>
<li>2014/Dec/22 &ndash; <a href="http://codereview.stackexchange.com/q/74521/507">Vector implementation</a></li>
<li>2015/Feb/17 &ndash; <a href="http://codereview.stackexchange.com/q/81751/507">Mathematical matrices implementation</a></li>
<li>2015/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/82906/507">C++ vector implementation errors</a></li>
<li>2015/Jun/20 &ndash; <a href="http://codereview.stackexchange.com/q/94211/507">Implementation of std::vector class</a></li>
<li>2015/Jul/08 &ndash; <a href="http://codereview.stackexchange.com/q/96253/507">Second implementation of std::vector</a></li>
<li>2015/Oct/17 &ndash; <a href="http://codereview.stackexchange.com/q/107877/507">Simple multi-dimensional Array class in C++11</a></li>
<li>2015/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/108072/507">Creating n-dimensional mathematical vector classes through inheritance</a></li>
<li>2015/Oct/20 &ndash; <a href="http://codereview.stackexchange.com/q/108140/507">Implementation of Vector in C++</a></li>
<li>2015/Oct/23 &ndash; <a href="http://codereview.stackexchange.com/q/108558/507">Simple multi-dimensional Array class in C++11 &ndash; follow-up</a></li>
<li>2015/Nov/18 &ndash; <a href="http://codereview.stackexchange.com/q/111114/507">Custom vector that uses less memory than std::vector</a></li>
<li>2015/Nov/24 &ndash; <a href="http://codereview.stackexchange.com/q/111746/507">Attempt at templates by creating a class for N-dimensional mathematical vectors</a></li>
<li>2016/Jan/10 &ndash; <a href="http://codereview.stackexchange.com/q/116377/507">Vector Implementation C++</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
