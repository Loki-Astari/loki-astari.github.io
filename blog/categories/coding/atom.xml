<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Coding | Loki Astari]]></title>
  <link href="http://lokiastari.com/blog/categories/coding/atom.xml" rel="self"/>
  <link href="http://lokiastari.com/"/>
  <updated>2016-03-19T22:33:47-07:00</updated>
  <id>http://lokiastari.com/</id>
  <author>
    <name><![CDATA[Loki Astari]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vector - Part 4: Simple Optimizations]]></title>
    <link href="http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations/"/>
    <updated>2016-03-19T15:06:40-07:00</updated>
    <id>http://lokiastari.com/blog/2016/03/19/vector-simple-optimizations</id>
    <content type="html"><![CDATA[<p>So now that we have used <code>std::is_nothrow_move_constructible</code> we can also look at a couple of other types available in the template utility library.</p>

<p>Since we have to manually call the destructor on all objects in the container (because we are using placement new) we can look to see if we can optimize that. The type <code>std::is_trivially_destructible</code> detects if the type is <strong>Trivially</strong> destructible. This basically means that there will be no side affects from the destructor (See: Section 12.4 Paragraph 5 of the standard). For types we don&rsquo;t need to call the destructor of the object. For the <code>Vector</code> class this means we can eliminate the call to the destructor but more importantly the loop.</p>

<p>```cpp Destroying Elements</p>

<pre><code>    ~Vector()
    {
        // STUFF..

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            throw;
        }
    }
</code></pre>

<p>```</p>

<p>We can use the same SFINAE technique that we used in the previous article to remove the loops when the contained type is trivially destructible.</p>

<p>```</p>

<pre><code>    ~Vector()
    {
        // STUFF..
        clearElements&lt;T&gt;();
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            // STUFF 1 ...
        }
        catch(...)
        {
            // STUFF 2 ...
            clearElements&lt;T&gt;();
            throw;
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
    clearElements()
    {
        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
    clearElements()
    {
        // Trivially destructible objects can be re-used without using the destructor.
    }
</code></pre>

<p>```</p>

<p>The final optimization is because resource allocation is expensive. So if we can avoid the resource allocation completely and just re-use the space we currently have.</p>

<p>```cpp Copy Assignment</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
</code></pre>

<p>```</p>

<p>The copy and swap idiom is perfect for providing the strong exception guarantee in the presence of exceptions. <strong>But</strong> if there are no exceptions during destruction or construction then we can potentially just re-use the available memory. So if we re-wrote the assignment operator with the assumption that there were no exceptions it would look like the following (Note in the real code use SFINAE to do the optimization only when nesacery).</p>

<p>```cpp Copy the easy way</p>

<pre><code>    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Check for self assignment
        // As we are doing work anyway.
        if (this == &amp;copy)
        {
            return *this;
        }

        // If the length of the `copy` object exceeds
        // the capacity of the current object then
        // we have to do resource management. It costs
        // nothing extra to use the copy and swap idiom
        if (copy.length &gt; capacity)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
            return *this;
        }

        // The optimization happens here.
        // We can reuse the buffer we already have.
        clearElements&lt;T&gt;();     // use cearElements() as it probably does very little.
        length = 0;

        // Now add the elements to this container as cheaply as possible.
        for(int loop = 0; loop &lt; copy.length; ++loop)
        {
            push_back_internal(copy[loop]);
        }
        return *this;
    }
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-4"></a></h1>

<p>The final version</p>

<p>```cpp Vector Final Version</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    std::size_t     capacity;
    std::size_t     length;
    T*              buffer;

    struct Deleter
    {
        void operator()(T* buffer) const
        {
            ::operator delete(buffer);
        }
    };

    public:
        Vector(int capacity = 10)
            : capacity(capacity)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {}
        ~Vector()
        {
            // Make sure the buffer is deleted even with exceptions
            // This will be called to release the pointer at the end
            // of scope.
            std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

            clearElements&lt;T&gt;();
        }
        Vector(Vector const&amp; copy)
            : capacity(copy.length)
            , length(0)
            , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
        {
            try
            {
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    push_back(copy.buffer[loop]);
                }
            }
            catch(...)
            {
                clearElements&lt;T&gt;();
                ::operator delete(buffer);

                // Make sure the exceptions continue propagating after
                // the cleanup has completed.
                throw;
            }
        }
        Vector&amp; operator=(Vector const&amp; copy)
        {
            copyAssign&lt;T&gt;(copy);
            return *this;
        }
        Vector(Vector&amp;&amp; move) noexcept
            : capacity(0)
            , length(0)
            , buffer(nullptr)
        {
            move.swap(*this);
        }
        Vector&amp; operator=(Vector&amp;&amp; move) noexcept
        {
            move.swap(*this);
            return *this;
        }
        void swap(Vector&amp; other) noexcept
        {
            using std::swap;
            swap(capacity,      other.capacity);
            swap(length,        other.length);
            swap(buffer,        other.buffer);
        }
        void push_back(T const&amp; value)
        {
            resizeIfRequire();
            push_back_internal(value);
        }
        void pop_back()
        {
            --length;
            buffer[length].~T();
        }
        void reserve(std::size_t capacityUpperBound)
        {
            if (capacityUpperBound &gt; capacity)
            {
                reserveCapacity(capacityUpperBound);
            }
        }
    private:
        void resizeIfRequire()
        {
            if (length == capacity)
            {
                std::size_t     newCapacity  = capacity * 1.62;
                reserveCapacity(newCapacity);
            }
        }
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            simpleCopy&lt;T&gt;(tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void push_back_internal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void move_back_internal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::forward&lt;T&gt;(value));
            ++length;
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.push_back_internal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.move_back_internal(std::move(v));}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == false&gt;::type
        clearElements()
        {
            // Call the destructor on all the members in reverse order
            for(int loop = 0; loop &lt; length; ++loop)
            {
                // Note we destroy the elements in reverse order.
                buffer[length - 1 - loop].~T();
            }
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_trivially_destructible&lt;X&gt;::value == true&gt;::type
        clearElements()
        {
            // Trivially destructible objects can be re-used without using the destructor.
        }

        template&lt;typename X&gt;
        struct InSimpleTrivial
        {
            static constexpr bool value = 
                    std::is_nothrow_copy_constructible&lt;X&gt;::value
                &amp;&amp;  std::is_nothrow_destructible&lt;X&gt;::value;
        };

        template&lt;typename X&gt;
        typename std::enable_if&lt;InSimpleTrivial&lt;T&gt;::value == true&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            if (this == &amp;copy)
            {
                return;
            }

            if (capacity &lt;= copy.length)
            {
                clearElements&lt;T&gt;();
                length = 0;
                for(int loop = 0; loop &lt; copy.length; ++loop)
                {
                    push_back_internal(copy[loop]);
                }
            }
            else
            {
                // Copy and Swap idiom
                Vector&lt;T&gt;  tmp(copy);
                tmp.swap(*this);
            }
        }
        template&lt;typename X&gt;
        typename std::enable_if&lt;InSimpleTrivial&lt;T&gt;::value == false&gt;::type
        copyAssign(Vector&lt;X&gt;&amp; copy)
        {
            // Copy and Swap idiom
            Vector&lt;T&gt;  tmp(copy);
            tmp.swap(*this);
        }
};
</code></pre>

<p>```</p>

<h1>Summary</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Part 3: Vector Resize]]></title>
    <link href="http://lokiastari.com/blog/2016/03/12/vector-resize/"/>
    <updated>2016-03-12T04:53:07-08:00</updated>
    <id>http://lokiastari.com/blog/2016/03/12/vector-resize</id>
    <content type="html"><![CDATA[<p>Because resizing a vector is expensive; the <code>std::vector</code> class uses exponential growth to minimize the number of times that the vector is resized. A technique we copied in this version. But every now and then you still need to do resize the internal buffer.</p>

<p>In the <a href="#VectorVersion-1">current version</a>, resizing the vector requires a new buffer be allocated and all the members copied into it. Basically we are using the copy and swap mechanism to provide the strong exception guarantee (If an exception is thrown all resources are cleaned up and the object remains unchanged).
```cpp Vector Resize with Copy</p>

<pre><code>    void push_back_internal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T const&amp; v){tmpBuffer.push_back_internal(v);}
                     );

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>```</p>

<p>Thus resizing a <code>Vector</code> can be a very expensive operation because of all the copying that can happen.</p>

<p>Using the move constructor rather than copy constructor during a resize operation could potentially be much more efficient. But the move constructor mutates the original object and thus if there is a problem we need to undo the mutations to maintain the strong exception guarantee.</p>

<p>The first attempt at this is:
```cpp Vector Resize with Move With Exceptions</p>

<pre><code>    void move_back_internal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::forward&lt;T&gt;(value));
        ++length;
    }

    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        try
        {
            std::for_each(buffer, buffer + length,
                          [&amp;tmpBuffer](T&amp; v){tmpBuffer.move_back_internal(std::move(v));}
                         );
        }
        catch(...)
        {
            // If an exception is throw you need to move the objects back
            // from the temporary buffer back to this object.
            for(int loop=0; loop &lt; tmpBuffer.length; ++loop)
            {
                // The problem is here:
                // If the initial move can throw,
                // then trying to move any of the objects back can also throw.
                // which would leave the object in an inconsistent state.
                buffer[loop] = std::move(tmpBuffer[loop]);
            }

            // Then remember to rethrow the exception after we have fixed the state.
            throw;
        }

        tmpBuffer.swap(*this);
    }
</code></pre>

<p><code>``
As the above code shows; if the type</code>T<code>can throw during it's move constructor then you can't guarantee that the object gets returned to the original state (as moving the already moved elements back may cause another exception). So we can not use the move constructor to resize the vector if the type</code>T` can throw during move construction.</p>

<p>But not all types throw when being moved. In fact it is recommended that move constructors never throw. If we can guarantee that the move constructor does not throw then we can simplify the above code considerably and still provide the strong exception guarantee.
```cpp Vector Resize with Move</p>

<pre><code>    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length,
                      [&amp;tmpBuffer](T&amp; v){tmpBuffer.move_back_internal(std::move(v));}
                     );

        tmpBuffer.swap(*this);
    }
    void move_back_internal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::forward&lt;T&gt;(value));
        ++length;
    }
</code></pre>

<p><code>
So now we have to write the code that decides at compile time which version we should use. The simplist way to do this is to use template specialization of a class using the standard class `std::is_nothrow_move_constructible&lt;T&gt;` to help deferentiate types that have a none throwing move constructor. This is simple enough:
</code>cpp Template class Specialization</p>

<pre><code>template&lt;typename T, bool = std::is_nothrow_move_constructible&lt;T&gt;::value&gt;
struct SimpleCopy
{
    // Define two different versions of this class.
    // The object is to copy all the elements from src to dst Vector
    // using push_back_internal or move_back_internal
    //
    // SimpleCopy&lt;T, false&gt;:        Defines a version that use push_back_internal (copy constructor)
    //                              This is always safe to use.
    // SimpleCopy&lt;T, true&gt;:         Defines a version that uses move_back_internal (move constructor)
    //                              Safe when move construction does not throw.
    //
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const;
};
template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        // We are using private methods for effeciency.
        // So these classes need to be friends.
        friend struct SimpleCopy&lt;T, true&gt;;
        friend struct SimpleCopy&lt;T, false&gt;;

        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            // Create the copier object base on the type T.
            // Note: The second parameter is automatically generated based
            //       on if the type T is move constructable with no exception.
            SimpleCopy&lt;T&gt;   copier;
            copier(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void push_back_internal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void move_back_internal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::forward&lt;T&gt;(value));
            ++length;
        }
}
// Define the two different types of copier
template&lt;typename T&gt;
struct SimpleCopy&lt;T, false&gt; // false: does not have nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.push_back_internal(v);}
                     );
    }
};
template&lt;typename T&gt;
struct SimpleCopy&lt;T, true&gt; // true: has a nothrow move constructor
{
    void operator()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst) const
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.move_back_internal(std::move(v));}
                     );
    }
};
</code></pre>

<p>```
This has technique has a couple of issues.</p>

<p>The type <code>SimpleClass</code> is publicly available and is a friend of <code>Vector&lt;T&gt;</code>. This makes it suseptable to accidently being used (even if not explicitly documented). Unfortunately it can&rsquo;t be included as a member class and also be specialized.</p>

<p>Additionally it looks awful!!</p>

<p>But we can also use <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a> and method overloading.</p>

<p>SFINAE allows us to define several versions of method with exactly the same arguments, as long as only one of them is valid at compile time. So in the example below we define two versions of the method <code>SimpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)</code> but then use <code>std::enable_if</code> to make sure only one version of the function id valid at compile time.</p>

<p>```cpp SFINAE method overload</p>

<pre><code>template&lt;typename T&gt;
class Vector
{
    public:
        .....
    private:
        void reserveCapacity(std::size_t newCapacity)
        {
            Vector&lt;T&gt;  tmpBuffer(newCapacity);

            SimpleCopy&lt;T&gt;(*this, tmpBuffer);

            tmpBuffer.swap(*this);
        }
        void push_back_internal(T const&amp; value)
        {
            new (buffer + length) T(value);
            ++length;
        }
        void move_back_internal(T&amp;&amp; value)
        {
            new (buffer + length) T(std::forward&lt;T&gt;(value));
            ++length;
        }

        template&lt;typename X&gt;
        // Note: this defines the return type of the function.
        //       But only one has a valid member `type` thus only
        //       one of the following funcionts is actually valid.
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
        simpleCopy(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T const&amp; v){dst.push_back_internal(v);}
                         );
        }

        template&lt;typename X&gt;
        typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
        simpleCopy()(Vector&lt;T&gt;&amp; src, Vector&lt;T&gt;&amp; dst)
        {
            std::for_each(buffer, buffer + length,
                          [&amp;dst](T&amp; v){dst.move_back_internal(std::move(v));}
                         );
        }
}
</code></pre>

<p>```</p>

<h1>Final Version <a id="VectorVersion-3"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            ::operator delete(buffer);

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        push_back_internal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = capacity * 1.62;
            reserveCapacity(newCapacity);
        }
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        simpleCopy&lt;T&gt;(tmpBuffer);

        tmpBuffer.swap(*this);
    }
    void push_back_internal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void move_back_internal(T&amp;&amp; value)
    {
        new (buffer + length) T(std::forward&lt;T&gt;(value));
        ++length;
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == false&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T const&amp; v){dst.push_back_internal(v);}
                     );
    }

    template&lt;typename X&gt;
    typename std::enable_if&lt;std::is_nothrow_move_constructible&lt;X&gt;::value == true&gt;::type
    simpleCopy(Vector&lt;T&gt;&amp; dst)
    {
        std::for_each(buffer, buffer + length,
                      [&amp;dst](T&amp; v){dst.move_back_internal(std::move(v));}
                     );
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of the resiing the internal buffer. We have covered a couple of techniques on the way</p>

<ul>
<li>Move Constructor Concepts</li>
<li>Template Class Specialization</li>
<li>SFINAE</li>
<li>std::is_nothrow_move_constructible&lt;&gt;</li>
<li>std::enable_if&lt;&gt;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Part 2: Resource Management Copy Swap]]></title>
    <link href="http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment/"/>
    <updated>2016-02-29T12:29:20-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/29/vector-resource-management-ii-copy-assignment</id>
    <content type="html"><![CDATA[<p>In the previous article I went over basic allocation for a <code>Vector</code> like class. In this article I want to put some detail around the copy assignment operator and re-sizing the underlying <code>Vector</code>. Unlike the other methods previously discussed these methods have to deal with both construction and destruction of elements and the potential of exceptions interrupting the processes. The goal is to provide an exception safe methods that provides the strong exception guarantee for the object and do not leak resources.</p>

<h1>Copy Assignment</h1>

<h2>First Try</h2>

<p>This is a very common first attempt at a copy constructor.<br/>
It simply calls the destructor on all elements currently in the object. Then uses the existing <code>push_back()</code> method to copy member elements from the source object, thus allowing the object to automatically re-size if required.</p>

<p>```cpp Copy Assignment (Try 1)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // First we have to destroy all the current elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Destroy in reverse order
        buffer[length - 1 - loop].~T();
    }
    // Now the buffer is empty so reset size to zero.
    length = 0;

    // Now copy all the elements from the source into this object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Strong Exception Guarantee</h2>

<p>The obvious problems about efficiency when a resize is required is a minor issue here. The real problem is that this does not provide the strong exception guarantee. If any of the constructors/destructor throw then the object will be left in an inconsistent state, with no way to restore the original state. The strong exception guarantee basically means that the operation works or does not change the state of the object. The easiest technique to achieve this we must create the copy into a new temporary buffer that can be thrown away if things go wrong (leaving the current object untouched). If the copy succeeds then we use it and can throw away the original data.</p>

<p>```cpp Copy Assignment (Try 2)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy of the src object.
    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }

    // Part-2 Swap the state
    // We have successfully created the new version of this object
    // So swap the temporary and object states.
    std::swap(tmpCap,    capacity);
    std::swap(tmpSize,   length);
    std::swap(tmpBuffer, buffer);

    // Part-3 Destroy the old state.
    // Now we have to delete the old state.
    // If this fails it does not matter the state of the object is consistent
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Copy and Swap</h2>

<p>This second attempt is a better attempt. But it still leaks if an exception is throw. But before we add exception handling, let us take a closer look at the three sections of the assignment operator.</p>

<p>Part-1 looks exactly like the copy constructor of Vector.</p>

<p>```cpp Copy Assignment Part 1</p>

<pre><code>    std::size_t tmpCap    = copy.length;
    std::size_t tmpSize   = 0;
    T*          tmpBuffer = static_cast&lt;T*&gt;(::operator new(sizeof(T) * tmpCap));

    // Now copy all the elements from the source into the temporary object
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        // This looks exactly like push_back()
        new (tmpBuffer + tmpSize) T(copy.buffer[loop]);
        ++tmpSize;
    }
</code></pre>

<p>```</p>

<p>Part-3 looks exactly like destructor of Vector.
```cpp Copy Assignment Part 3</p>

<pre><code>    // Now we have to delete the old state.
    for(int loop = 0; loop &lt; tmpSize; ++loop)
    {
        tmpBuffer[tmpSize - 1 - loop].~T();
    }
    ::operator delete(tmpBuffer);
</code></pre>

<p>```</p>

<p>Using these two observations we have a re-write of the copy assignment operator.</p>

<p>```cpp Copy Assignment (Try 3)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    if (&amp;copy == this)
    {
        // Early exit for self assignment
        return *this;
    }
    // Part-1 Create a copy
    Vector  tmp(copy);

    // Part-2 Swap the state
    std::swap(tmp.capacity, capacity);
    std::swap(tmp.length,   length);
    std::swap(tmp.buffer,   buffer);

    return *this;
    // Part-3 Destructor called at end of scope.
    // No actual code required here.
}
</code></pre>

<p>};
```</p>

<h2><a href="http://stackoverflow.com/q/3279543/14065">Copy And Swap Idiom</a></h2>

<p>The copy and swap idiom is about dealing with replacing an object state from another object. It is very commonly used in the copy assignment operator but has application whenever state is being changed and the <a href="https://en.wikipedia.org/wiki/Exception_safety">strong exception guarantee</a> is required.</p>

<p>The above code works perfectly. But in Part-2 the swap looks like a normal swap operation so lets use that rather than doing it manually. Also self assignment now works without the need for a test (because we are copying into a temporary). So we can remove the check for self assignment. Yes this does make the performance for self assignment worse, but it make the normal operation even more efficient. Since the occurrences of self assignment are extremely rare I would not prematurely optimize for them and make the most common case the best optimized. So one final re-factor of the copy constructor leaves us with this.</p>

<p>```cpp Copy Assignment (Try 4)
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF
Vector&amp; operator=(Vector const&amp; copy)
{
    Vector  tmp(copy);
    tmp.swap(*this);
    return *this;
}
void swap(Vector&amp; other) noexcept
{
    std::swap(other.capacity, capacity);
    std::swap(other.length,   length);
    std::swap(other.buffer,   buffer);
}
</code></pre>

<p>};
```</p>

<h1>Resizing Underling buffer</h1>

<p>When pushing data into the array we need to verify that capacity has not been exceeded. If it has then we to allocate more capacity then copy the current content into the new buffer and destroy the old buffer, after calling the destructor on all elements.</p>

<h2>Using Copy and Swap</h2>

<p>This operation is exceedingly similar to the description we did with the copy assignment operator. As a result the best solution looks very similar and used the Copy and Swap Idiom.</p>

<p>```cpp Vector Reallocating Buffer
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    
void resizeIfRequire()
{
    if (length == capacity)
    {
        // Create a temporary object with a larger capacity.
        std::size_t     newCapacity  = capacity * 1.62;
        Vector&lt;T&gt;  tmpBuffer(newCapacity);

        // Copy the state of this object into the new object.
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; item){tmpBuffer.push_back(item);});

        // All the work has been successfully done. So swap
        // the state of the temporary and the current object.
        tmpBuffer.swap(*this);

        // The temporary object goes out of scope here and
        // tidies up the state that is no longer needed.
    }
}
</code></pre>

<p>};
```</p>

<h1>Final Version <a id="VectorVersion-2"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            ::operator delete(buffer);

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Copy and Swap idiom
        Vector&lt;T&gt;  tmp(copy);
        tmp.swap(*this);
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        push_back_internal(value);
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
    void reserve(std::size_t capacityUpperBound)
    {
        if (capacityUpperBound &gt; capacity)
        {
            reserveCapacity(capacityUpperBound);
        }
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            std::size_t     newCapacity  = capacity * 1.62;
            reserveCapacity(newCapacity);
        }
    }
    void push_back_internal(T const&amp; value)
    {
        new (buffer + length) T(value);
        ++length;
    }
    void reserveCapacity(std::size_t newCapacity)
    {
        Vector&lt;T&gt;  tmpBuffer(newCapacity);
        std::for_each(buffer, buffer + length, [&amp;tmpBuffer](T const&amp; v){tmpBuffer.push_back_internal(v);});

        tmpBuffer.swap(*this);
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has gone over the design of the Copy and Swap Idiom and show how it is used in the Copy Assignment Operator and the resize operation.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Copy and Swap Idiom</li>
<li>Exception Grantees</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vector - Part 1: Resource Management Allocation]]></title>
    <link href="http://lokiastari.com/blog/2016/02/27/vector/"/>
    <updated>2016-02-27T12:00:31-08:00</updated>
    <id>http://lokiastari.com/blog/2016/02/27/vector</id>
    <content type="html"><![CDATA[<p>A lot of new developers to C++ attempt to build a <code>Vector</code> like container as a learning processes. Getting a simple version of this working for POD types (like int) is not that complicated. The next step in getting this working for arbitrary data types takes a significant leap forward in thinking in C++ especially when you start looking at efficiency and exception safety. This set of four articles looks at building an efficient <code>Vector</code> implementation. I show some of the common mistakes and explain why and how to resolve the problems:</p>

<p>I will use three articles to cover the different parts I want to illustrate:</p>

<ol>
<li>Resource Management I:   Allocation</li>
<li>Resource Management II:  Copy Assignment</li>
<li>Resource Management III: Resize</li>
<li>Container Concepts.</li>
</ol>


<p>Note: This is not meant to replace <code>std::vector&lt;&gt;</code> this simply meant as a teaching processes.</p>

<h2>Rule of Zero</h2>

<p>You will notice that half the attempts below <a href="#Sources">Sources</a> are Vector implementations the other half are for Matrix implementations. I mention both because I want to emphasize the <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>. An object should be responsible for either business logic or resource management (not both). A lot of the Matrix implementations are trying to mix resource management (memory management) with the business logic of how matrices interact. So if you want to write a matrix class you should delegate resource management to a separate class (In a first pass <code>std::vector&lt;int&gt;</code> would be a good choice).</p>

<p>In C++ the compiler generates a couple of methods for free.</p>

<ul>
<li>Destructor</li>
<li>Copy Constructor</li>
<li>Copy Assignment Operator</li>
<li>Move Constructor</li>
<li>Move Assignment Operator</li>
</ul>


<p>These methods usually work perfectly well; <strong>unless</strong> your class contains a pointer (or a pointer like resource object). But if your class is doing business logic then it should not contain a pointer. So classes that handle business logic therefore should not be defining any of these compiler generated methods (just let the compiler generated ones work for you). Occasionally you want to delete them, to prevent copying or movement, but it is very unusual for these to need specialized implementations.</p>

<p>Conversely, classes that do resource management usually contain a pointer (or pointer like resource object). These classes should define all the above methods to correctly handle the resource. This is where ownership semantics of the resource are defined. The owner of the resource is responsible for destroying the resource when its lifespan is over (in terms of pointers this means the owner is responsible for calling <code>delete</code> on the pointer, usually in the destructor). If you are not the owner of a resource you should not have access to the resource object directly, as it may be destroyed by the owner without other objects knowing.</p>

<h1><a href="http://stackoverflow.com/q/4172722/14065">Rule of three</a></h1>

<h2>Version-1 Simple Resource Management</h2>

<p>When creating a class to manage resources; the first version created by beginner usually looks like this:</p>

<p>```cpp Rule of three first pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])   // Allocate the resource
{}
~Vector()
{
    delete [] buffer;       // Clean up the resource
}
</code></pre>

<p>};
```
The trouble here is that this version has a fundamental flaw because of the way the <a href="http://stackoverflow.com/a/4044360/14065">compiler generated</a> copy constructor and copy assignment operator work with pointers (commonly referred to as the <a href="http://stackoverflow.com/q/2344664/14065">shallow copy problem</a>).</p>

<p>```cpp Shallow copy problem.
int main()
{</p>

<pre><code>Vector&lt;int&gt;   x;
Vector&lt;int&gt;   y(x);     // Compiler generate copy constructure does
                        // an element wise shallow copy of each element.
                        // This means both `x` and `y` have a buffer
                        // member that points at the same area in memory.
                        //
                        // When the objects go out of scope both will
                        // try and call delete on the memory resulting
                        // in a double delete of the memory.

Vector&lt;int&gt;   z;        // Same problem after an assignment.
z=x;
</code></pre>

<p>}
```</p>

<h2>Version-2 Rule of Three</h2>

<p>The rule of three simply stated is: If you define any of the methods Destructor/Copy Constructor/Copy Assignment Operator then you should define all three. When done correctly this resolves the shallow copy problem. <code>Vector</code> defines the destructor so we also need to define the copy constructor and copy assignment operator.</p>

<p>I see this as an initial attempt at defining the rule of three for vectors very often.</p>

<p>```cpp Rule of three second pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     size;
T*              buffer;
Vector(int size = 100)
    : size(size)
    , buffer(new T[size])
{}
~Vector()
{
    delete [] buffer;
}
Vector(Vector const&amp; copy)
    : size(copy.size)
    , buffer(new T[size])
{
    // Copy constructor is simple.
    // We create a new resource area of the required size.
    // Then we copy the data from the old buffer to the new buffer.
    std::copy(copy.buffer, copy.buffer + copy.size, copy);
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
</code></pre>

<p>};
```</p>

<h2>Version-3 Lazy Construction of elements.</h2>

<p>The problem with the previous version is that it forces initialization of all elements in the buffer immediately. This forces the requirement that members of the <code>Vector</code> (i.e. type <code>T</code>) must be default constructable. It also has two efficiency constraints imposed on the Vector:</p>

<ul>
<li>You can&rsquo;t pre-allocate space for future members.

<ul>
<li>So resizing (larger or smaller) becomes very expensive as each resize requires copy all the elements to the newly re-sized buffer.</li>
<li>Alternatively pre-creating all the elements you need can also be expensive especially if construction of <code>T</code> is expensive.</li>
</ul>
</li>
<li>The copy constructor is twice as expensive as it should be. Each element must be:

<ul>
<li>Default constructed (when the buffer is created).</li>
<li>Then copy constructed with the value from the source vector.</li>
</ul>
</li>
</ul>


<p>This attempt improves on that by allowing efficient pre-allocating of space (<code>capacity</code>) for the buffer. New members are then added by constructing in place using <a href="http://stackoverflow.com/questions/362953/what-are-uses-of-the-c-construct-placement-new">placement new</a>.</p>

<p>```cpp Rule of three third pass
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
Vector(int capacity)
    : capacity(capacity = 100)
    , length(0)
    // Allocates space but does not call the constructor
    , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    // Useful if the type T has an expensive constructor
    // We preallocate space without initializing it giving
    // room to grow and shrink the buffer without re-allocating.
{}
~Vector()
{
    // Because elements are constructed in place using
    // placement new. Then we must manually call the destructor
    // on the elements.
    for(int loop = 0; loop &lt; length; ++loop)
    {
        // Note we destroy the elements in reverse order.
        buffer[length - 1 - loop].~T();
    }
    ::operator delete(buffer);
}
Vector(Vector const&amp; copy)
    : capacity(copy.length)
    , length(0)
    , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
{
    // Copy constructor is simple.
    // We create a new resource area of the required length.
    // But these elements are not initialized so we use push_back to copy them
    // into the new object. This is an improvement because we
    // only construct the members of the vector once.
    for(int loop = 0; loop &lt; copy.length; ++loop)
    {
        push_back(copy.buffer[loop]);
    }
}
Vector&amp; operator=(Vector const&amp; copy)
{
    // Copy Object
    // This is relatively easy. But I want to cover this in detail in a subsquent post.
    return *this;
}
void push_back(T const&amp; value)
{
    // Use placement new to copy buffer into the new buffer
    new (buffer + length) T(value);
    ++length;

    // Note we will handle growing the capacity later.
}
void pop_back()
{
    // When removing elements need to manually call the destructor
    // because we created them using placement new.
    --length;
    buffer[length].~T();
}
</code></pre>

<p>};
```</p>

<h1>Rule of Five</h1>

<p>In C++11 the language add the concept of &ldquo;Move Semantics&rdquo;. Rather than having to copy an object (especially on return from a function) we could &ldquo;move&rdquo; an object. The concept here is that movement is supposed to be much cheaper than copy because you move the internal data structure of an object rather than all the elements. A good example is a std::vector. Pre C++11 a return by value means copying the object. The constructor of the new object allocates a new internal buffer and then copies all the elements from the original objects buffer to the new objects buffer. On the other hand a move simply gives the new object the internal buffer of the old object (we just move the pointer to the internal buffer). When an object is moved to another object the old object should be left in a valid state, but for efficiency the standard rarely specifies the state of an object after it has been the source of a move. Thus using an object after a move is a bad idea unless you are setting it to a specific state.</p>

<p>There are two new method that allow us to specify move semantics on a class.</p>

<p>```cpp Vector Move Semantics.
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept;

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept;
</code></pre>

<p>};
```</p>

<p>Notice the <code>&amp;&amp;</code> operator. This donates an r-value reference and means that your object is the destination of a move operation. The parameter passed is the source object and the state you should use to define your new objects state. After the move the source object must be left in a valid (but can be undefined state). For a vector this means it must no longer be the owner of the internal buffer that you are now using in your buffer.</p>

<p>The simplest way to achieve this goal is to set up the object in a valid (but very cheap to achieve state) and then swap the current object with the destination object.</p>

<p>```cpp Vector Move Semantics Implementation
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;
// STUFF    

// Move Constructor
Vector(Vector&amp;&amp; move) noexcept
    : capacity(0)
    , length(0)
    , buffer(nullptr)
{
    // The source object now has a nullptr/
    // This object has taken the state of the source object.
    move.swap(*this);
}

// Move Assignment Operator
Vector&amp; operator=(Vector&amp;&amp; move) noexcept
{
    // In this case simply swap the source object
    // and this object around.
    move.swap(*this);
}
</code></pre>

<p>};
```</p>

<p>Note I marked both move operators <code>noexcept</code>. Assuming the operations are guaranteed not to throw you should mark them as <code>noexcept</code>. If we know that certain operations are exception safe, then we can optimize resize operations and maintain the strong exception guarantee. This and some other optimizations will be documented in a subsequent post.</p>

<h1>Final Version <a id="VectorVersion-1"></a></h1>

<p>```cpp Vector Final Version
template<typename T>
class Vector
{</p>

<pre><code>std::size_t     capacity;
std::size_t     length;
T*              buffer;

struct Deleter
{
    void operator()(T* buffer) const
    {
        ::operator delete(buffer);
    }
};

public:
    Vector(int capacity = 10)
        : capacity(capacity)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {}
    ~Vector()
    {
        // Make sure the buffer is deleted even with exceptions
        // This will be called to release the pointer at the end
        // of scope.
        std::unique_ptr&lt;T, Deleter&gt;     deleter(buffer, Deleter());

        // Call the destructor on all the members in reverse order
        for(int loop = 0; loop &lt; length; ++loop)
        {
            // Note we destroy the elements in reverse order.
            buffer[length - 1 - loop].~T();
        }
    }
    Vector(Vector const&amp; copy)
        : capacity(copy.length)
        , length(0)
        , buffer(static_cast&lt;T*&gt;(::operator new(sizeof(T) * capacity)))
    {
        try
        {
            for(int loop = 0; loop &lt; copy.length; ++loop)
            {
                push_back(copy.buffer[loop]);
            }
        }
        catch(...)
        {
            // If there was an exception then destroy everything
            // that was created to make it exception safe.
            for(int loop = 0; loop &lt; length; ++loop)
            {
                buffer[length - 1 - loop].~T();
            }
            ::operator delete(buffer);

            // Make sure the exceptions continue propagating after
            // the cleanup has completed.
            throw;
        }
    }
    Vector&amp; operator=(Vector const&amp; copy)
    {
        // Covered in Part 2
        return *this;
    }
    Vector(Vector&amp;&amp; move) noexcept
        : capacity(0)
        , length(0)
        , buffer(nullptr)
    {
        move.swap(*this);
    }
    Vector&amp; operator=(Vector&amp;&amp; move) noexcept
    {
        move.swap(*this);
        return *this;
    }
    void swap(Vector&amp; other) noexcept
    {
        using std::swap;
        swap(capacity,      other.capacity);
        swap(length,        other.length);
        swap(buffer,        other.buffer);
    }
    void push_back(T const&amp; value)
    {
        resizeIfRequire();
        new (buffer + length) T(value);
        ++length;
    }
    void pop_back()
    {
        --length;
        buffer[length].~T();
    }
private:
    void resizeIfRequire()
    {
        if (length == capacity)
        {
            // Covered in Part 2
        }
    }
</code></pre>

<p>};
```</p>

<h1>Summary</h1>

<p>This article has shown how to handle the basic resource management required by a vector. It has covered several important principles for C++ programmers.</p>

<ul>
<li>Separation Of Concerns</li>
<li>Rule of Zero</li>
<li>Rule of Three</li>
<li>Rule of Five</li>
<li>Default compiler generated methods</li>
<li>Shallow Copy Problem</li>
<li>Placement New</li>
<li>Exception Grantees</li>
</ul>


<h1>Sources  <a id="Sources"></a></h1>

<p>Looking at <a href="http://CodeReview.stackexchange.com">CodeReview.stackexchange.com</a>; reimplementing the vector class is a common goal for a first project.</p>

<ul>
<li>2011/Nov/07 &ndash; <a href="http://codereview.stackexchange.com/q/5856/507">Mathematical Vector2 class implementation</a>*</li>
<li>2012/May/21 &ndash; <a href="http://codereview.stackexchange.com/q/11934/507">C++ Vector2 Class Review</a>*</li>
<li>2012/Aug/17 &ndash; <a href="http://codereview.stackexchange.com/q/14784/507">Templated Matrix class</a></li>
<li>2013/Jan/07 &ndash; <a href="http://codereview.stackexchange.com/q/20243/507">Vector implementation &ndash; simple replacement</a></li>
<li>2013/May/25 &ndash; <a href="http://codereview.stackexchange.com/q/26608/507">Review of 2d Vector class</a></li>
<li>2013/Jun/19 &ndash; <a href="http://codereview.stackexchange.com/q/27573/507">Simple matrix class</a></li>
<li>2013/Jun/21 &ndash; <a href="http://codereview.stackexchange.com/q/27625/507">Matrix and Vector4 classes</a>*</li>
<li>2013/Jun/25 &ndash; <a href="http://codereview.stackexchange.com/q/27752/507">Simple matrix class &ndash; version 2</a>*</li>
<li>2013/Aug/03 &ndash; <a href="http://codereview.stackexchange.com/q/29331/507">Template vector class</a>*</li>
<li>2014/Feb/20 &ndash; <a href="http://codereview.stackexchange.com/q/42297/507">C++ vector implementation</a></li>
<li>2014/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/43136/507">Reimplementation of C++ vector</a></li>
<li>2014/Mar/12 &ndash; <a href="http://codereview.stackexchange.com/q/44167/507">3D mathematical vector class</a></li>
<li>2014/May/17 &ndash; <a href="http://codereview.stackexchange.com/q/50975/507">Creating a custom Vector class</a></li>
<li>2014/Aug/19 &ndash; <a href="http://codereview.stackexchange.com/q/60484/507">STL vector implementation</a></li>
<li>2014/Sep/12 &ndash; <a href="http://codereview.stackexchange.com/a/62774/507">C++ 3D Vector Implementation</a></li>
<li>2014/Sep/26 &ndash; <a href="http://codereview.stackexchange.com/q/63970/507">Custom mathematical vector class</a></li>
<li>2014/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/67209/507">Vector backed by memory pages</a></li>
<li>2014/Oct/31 &ndash; <a href="http://codereview.stackexchange.com/q/68486/507">Custom matrix class</a></li>
<li>2014/Nov/25 &ndash; <a href="http://codereview.stackexchange.com/q/70815/507">Vector/matrix class</a></li>
<li>2014/Dec/22 &ndash; <a href="http://codereview.stackexchange.com/q/74521/507">Vector implementation</a></li>
<li>2015/Feb/17 &ndash; <a href="http://codereview.stackexchange.com/q/81751/507">Mathematical matrices implementation</a></li>
<li>2015/Mar/01 &ndash; <a href="http://codereview.stackexchange.com/q/82906/507">C++ vector implementation errors</a></li>
<li>2015/Jun/20 &ndash; <a href="http://codereview.stackexchange.com/q/94211/507">Implementation of std::vector class</a></li>
<li>2015/Jul/08 &ndash; <a href="http://codereview.stackexchange.com/q/96253/507">Second implementation of std::vector</a></li>
<li>2015/Oct/17 &ndash; <a href="http://codereview.stackexchange.com/q/107877/507">Simple multi-dimensional Array class in C++11</a></li>
<li>2015/Oct/19 &ndash; <a href="http://codereview.stackexchange.com/q/108072/507">Creating n-dimensional mathematical vector classes through inheritance</a></li>
<li>2015/Oct/20 &ndash; <a href="http://codereview.stackexchange.com/q/108140/507">Implementation of Vector in C++</a></li>
<li>2015/Oct/23 &ndash; <a href="http://codereview.stackexchange.com/q/108558/507">Simple multi-dimensional Array class in C++11 &ndash; follow-up</a></li>
<li>2015/Nov/18 &ndash; <a href="http://codereview.stackexchange.com/q/111114/507">Custom vector that uses less memory than std::vector</a></li>
<li>2015/Nov/24 &ndash; <a href="http://codereview.stackexchange.com/q/111746/507">Attempt at templates by creating a class for N-dimensional mathematical vectors</a></li>
<li>2016/Jan/10 &ndash; <a href="http://codereview.stackexchange.com/q/116377/507">Vector Implementation C++</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Smart Pointer Constructors]]></title>
    <link href="http://lokiastari.com/blog/2015/01/23/c-plus-plus-by-example-smart-pointer-part-iii/"/>
    <updated>2015-01-23T16:33:14-08:00</updated>
    <id>http://lokiastari.com/blog/2015/01/23/c-plus-plus-by-example-smart-pointer-part-iii</id>
    <content type="html"><![CDATA[<p>In this article we examine constructors that are often missed or overlooked. This article looks at the use cases for these constructors and explains why the added functionality provides a meaningful addition in relation to smart pointers.</p>

<h2>Default Constructor</h2>

<p>Most people remember the default constructor (a zero argument constructor), but every now and then it gets missed.</p>

<p>The default constructor is useful when the type is used in a context where objects of the type need to be instantiated dynamically by another library (an example is a container resized; when a container is made larger by a resize, new members will need to be constructed, it is the default constructor that will provide these extra instances).</p>

<p>The default constructor is usually very trivial and thus worth the investment.
```cpp Smart Pointer Default Constructor</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            UP()
                : data(nullptr)
            {}
            .....
    };
}
</code></pre>

<p>```</p>

<h2>The nullptr</h2>

<p>In C++11 the <code>nullptr</code> was introduced to replace the old broken <code>NULL</code> and/or the even more broken <code>0</code> for use in contexts where you want a pointer that points at nothing. The <code>nullptr</code> is automatically convert to any pointer type or a boolean; but fixed the previous bug (or bad feature) and will not convert to a numeric type.
```cpp nullptr Usage Example</p>

<h1>include <string></h1>

<pre><code>int main()
{
    char*           tmp = nullptr;   // converts the nullptr (type std::nullptr_t) to char*
    std::string*    str = nullptr;   // hopefully you never do that! but it works.

    bool            tst = nullptr;   // False. Yes I know it does not look that useful.
                                     //        But when you consider all the funny things
                                     //        that can happen with templates this can
                                     //        be very useful.

    int             val = nullptr;   // Fails to compile.
    int             val = NULL;      // Pointer assigned to integer value.
                                     // Works just fine. But very rarely was this a useful
                                     // feature (more usually an over-site that was not
                                     // reported by the compiler).
}
</code></pre>

<p><code>
The `nullptr` provides some opportunities to make the code shorter/cleaner when initializing smart pointers to be empty. Because we are using explicit one argument constructors the compiler can not convert a `nullptr` into a smart pointer automatically, it must be done explicitly by the developer.
</code>cpp nullptr failing on Smart Pointer</p>

<pre><code>void workWithSP(ThorsAnvil::UP&lt;int&gt;&amp;&amp; sp)
{ /* STUFF*/ }

int main()
{
    // This fails to compile.
    workWithSP(nullptr);

    // Need to be explicit with smart pointers
    workWithSP(ThorsAnvil::UP&lt;int&gt;(nullptr));
}
</code></pre>

<p><code>
This is overly verbose, there is no danger involved in forming a smart pointer around a `nullptr` automatically. Because `nullptr` has its own type `std::nullptr_t` we can add a constructor to explicitly simplify this case, which makes it easier to read.
</code>cpp Smart Pointer with std::nullptr_t constructor</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        public:
            UP(std::nullptr_t)
                : data(nullptr)
            {}
    ....
    };
}
// Now we can simplify our use case
void workWithSP(ThorsAnvil::UP&lt;int&gt;&amp;&amp; sp)
{ /* STUFF*/ }

int main()
{
    workWithSP(nullptr);

    // Note this also allows:
    ThorsAnvil::UP&lt;int&gt;   data  = nullptr;
    // And
    data = nullptr;       // Note here we have we convert nullptr to
                          // smart pointer using the one argument
                          // constructor that binds `nullptr` then
                          // call the assignment operator.
                          //
                          // That seems like a lot extra work. So we
                          // may as well define the assignment operator
                          // to specifically user `nullptr`.
}
</code></pre>

<p>```</p>

<h2>Move Semantics</h2>

<p>Move semantics were introduced with C++ 11. So though we can not copy the <code>ThorsAnvil::UP</code> object it can be moved. The compiler will generate a default move constructor for a class under certain situations; but because we have defined a destructor for <code>ThorsAnvil::UP</code> we must manually define the move constructor.</p>

<p>Move semantics say that the source object may be left in an undefined (but must be valid) state. So the easiest way to implement this is simply to swap the state of the current object with the source object (we know our state is valid so just swap it with the incoming object state (its destructor will then take care of destroying the pointer we are holding)).
```cpp Smart Pointer Move Semantics</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            // Swap should always be `noexcept` operation
            void swap(UP&amp; src) noexcept
            {
                std::swap(data, src.data);
            }
            // It is a good idea to make your move constructor `noexcept`
            // In this case it actually makes no difference (because there
            // no copy constructor) but to maintain good practice I still
            // think it is a good idea to mark it with `noexcept`.
            UP(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
            }
            UP&amp; operator=(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
                return *this;
            }
            .....
    };
    template&lt;typename T&gt;
    void swap(UP&lt;T&gt;&amp; lhs, UP&lt;T&gt;&amp; rhs)
    {
        lhs.swap(rhs);
    }
}
</code></pre>

<p>```</p>

<h2>Derived Type Assignment.</h2>

<p>Assigning derived class pointers to a base class pointer object is quite common feature in C++.
```cpp Derived Example</p>

<pre><code>class Base
{
    public:
        virtual ~Base() {}
        virtual void doAction() = 0;
};
class Derived1: public Base
{
    public:
        virtual void doAction() override;
};
class Derived2: public Base
{
    public:
        virtual void doAction() override;
};
int main(int argc, char* argv[])
{
    Derived1*   action1 = new Derived1;
    Derived2*   action2 = new Derived2;

    Base*       action   = (argc == 2) ? action1 : action2;
    action-&gt;doAction();
}
</code></pre>

<p><code>
If we try the same code with the constructors we currently have we will get compile errors.
</code>cpp Derived Example with Smart Pointers</p>

<pre><code>int main(int argc, char* argv[])
{
    ThorsAnvil::UP&lt;Derived1&gt;    action1 = new Derived1;
    ThorsAnvil::UP&lt;Derived2&gt;    action2 = new Derived2;

    ThorsAnvil::UP&lt;Base&gt;        action   = std::move((argc == 2) ? action1 : action2);
    action-&gt;doAction();
}
</code></pre>

<p><code>``
This is because C++ considers</code>ThorsAnvil::UP<Derived1><code>,</code>ThorsAnvil::UP<Derived2><code>and</code>ThorsAnvil::UP<Base>` are three distinct classes that are unrelated. As this kind of pointer usage is rather inherent in how C++ is used the smart pointer needs to be designed for this use case.</p>

<p>To solve this we need to allow different types of smart pointer be constructed from other types of smart pointer, but only where the inclosed types are related.
```cpp Derived Smart Pointer transfer</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*      data;
        public:
            // Release ownership of the pointer.
            // Returning the pointer to the caller.
            T*  release()
            {
                T* tmp = nullptr;
                std::swap(tmp, data);
                return tmp;
            }
            // Note: If you try calling this with a U that is not derived from
            //       a T then the compiler will generate a compilation error as
            //       the pointer assignments will not match correctly.
            template&lt;typename U&gt;
            UP(UP&lt;U&gt;&amp;&amp; moving)
            {
                // We can not use swap directly.
                // Even though U is derived from T, the reverse is not true.
                // So we have put it in a temporary locally first.

                // Note: this is still exception safe.
                //       The normal constructor will call delete even if it does
                //       not finish constructing. So if release completes even
                //       starting the call to the constructor guarantees its safety.
                UP&lt;T&gt;   tmp(moving.release());
                tmp.swap(*this);
            }
            template&lt;typename U&gt;
            UP&amp; operator=(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;    tmp(moving.release());
                tmp.swap(*this);
                return *this;
            }
            .....
    };
}
</code></pre>

<p>```</p>

<h2>Updated Unique Pointer</h2>

<p>Combine the constructor/assignment operators discussed in this article with the <code>ThorsAnvil::UP</code> that we defined in the first article in the series: <a href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">Unique Pointer</a> we obtain the following:
```cpp ThorsAnvil::UP Version 3</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*   data;
        public:
            UP()
                : data(nullptr)
            {}
            // Explicit constructor
            explicit UP(T* data)
                : data(data)
            {}
            ~UP()
            {
                delete data;
            }

            // Constructor/Assignment that binds to nullptr
            // This makes usage with nullptr cleaner
            UP(std::nullptr_t)
                : data(nullptr)
            {}
            UP&amp; operator=(std::nullptr_t)
            {
                reset();
                return *this;
            }

            // Constructor/Assignment that allows move semantics
            UP(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
            }
            UP&amp; operator=(UP&amp;&amp; moving) noexcept
            {
                moving.swap(*this);
                return *this;
            }

            // Constructor/Assignment for use with types derived from T
            template&lt;typename U&gt;
            UP(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;   tmp(moving.release());
                tmp.swap(*this);
            }
            template&lt;typename U&gt;
            UP&amp; operator=(UP&lt;U&gt;&amp;&amp; moving)
            {
                UP&lt;T&gt;    tmp(moving.release());
                tmp.swap(*this);
                return *this;
            }

            // Remove compiler generated copy semantics.
            UP(UP const&amp;)            = delete;
            UP&amp; operator=(UP const&amp;) = delete;

            // Const correct access owned object
            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}

            // Access to smart pointer state
            T* get()                 const {return data;}
            explicit operator bool() const {return data;}

            // Modify object state
            T* release() noexcept
            {
                T* result = nullptr;
                std::swap(result, data);
                return result;
            }
            void swap(UP&amp; src) noexcept
            {
                std::swap(data, src.data);
            }
            void reset()
            {
                T* tmp = releae();
                delete tmp;
            }
    };
    template&lt;typename T&gt;
    void swap(UP&lt;T&gt;&amp; lhs, UP&lt;T&gt;&amp; rhs)
    {
        lhs.swap(rhs);
    }
}
</code></pre>

<p>```</p>

<h2>Summary</h2>

<p>In the last two articles (<a href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">Unique Pointer</a> and <a href="http://lokiastari.com/blog/2015/01/15/c-plus-plus-by-example-smart-pointer-part-ii/">Shared Pointer</a>) we covered some basic mistakes that I have often seen developers make when attempting to creating their own smart pointer. I also introduce four important C++ concepts:</p>

<ul>
<li><a href="http://stackoverflow.com/q/4172722/14065">Rule of Three</a></li>
<li><a href="http://stackoverflow.com/q/3279543/14065">Copy and Swap Idiom</a></li>
<li><a href="http://stackoverflow.com/a/121163/14065">Explicit One Argument Constructor</a></li>
<li><a href="http://stackoverflow.com/q/12697625/14065">Try/Catch on Initialization List</a></li>
</ul>


<p>This article I focused on a couple of constructors/assignment operators that can be overlooked overlooked.</p>
]]></content>
  </entry>
  
</feed>
