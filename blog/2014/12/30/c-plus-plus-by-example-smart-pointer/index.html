
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>C++ By Example: Smart Pointer - Loki Astari</title>
  <meta name="author" content="Loki Astari">

  
  <meta name="description" content="">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/bootstrap/bootstrap.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/bootstrap/responsive.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/syntax/syntax.css" media="screen, projection" rel="stylesheet" type="text/css">
  <style type="text/css">
    body {
      padding-bottom: 40px;
    }
    h1 {
      margin-bottom: 15px;
    }
    img {
      max-width: 100%;
    }
    .sharing, .meta, .pager {
      margin: 20px 0px 20px 0px;
    }
    .page-footer p {
      text-align: center;
    }
  </style>
  <script src="/javascripts/libs/jquery.js"></script>
  <script src="/javascripts/libs/modernizr-2.0.js"></script>
  <script src="/javascripts/libs/bootstrap.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="http://feeds.feedburner.com/LokiAstari" rel="alternate" title="Loki Astari" type="application/atom+xml">
  
  

</head>

<body   >
  <nav role="navigation"><div class="navbar navbar-inverse">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a class="brand" href="/">Loki Astari</a>

      <div class="nav-collapse">
        <ul class="nav">
  <li><a href="/">Blog</a></li>
  <li><a href="/about/">About</a></li>
  <li><a href="/so-you-want-to-learn-c-plus-plus/">So you want to learn C++</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>


        <ul class="nav pull-right" data-subscription="rss">
          <li><a href="http://feeds.feedburner.com/LokiAstari" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
          
        </ul>

        
          <form class="pull-right navbar-search" action="http://google.com/search" method="get">
            <fieldset role="search">
              <input type="hidden" name="q" value="site:lokiastari.com" />
              <input class="search-query" type="text" name="q" results="0" placeholder="Search"/>
            </fieldset>
          </form>
        
      </div>
    </div>
  </div>
</div>
</nav>
  <div class="container">
    <div class="row-fluid">
      
<article class="hentry span9" role="article">

  
  <header class="page-header">
    
      <h1 class="entry-title">C++ by Example: Smart Pointer</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-12-30T18:41:42-08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>On <a href="codereview.stackexchange.com">codereview.stackexchange.com</a> in the C++ tag it seems that a write of passage to implement your own version of a smart pointer. A quick search brings up the following:</p>

<ul>
<li>02/Sep/2011 &ndash; <a href="http://codereview.stackexchange.com/q/4550/507">shared_ptr implementation</a></li>
<li>26/Nov/2011 &ndash; <a href="http://codereview.stackexchange.com/q/6320/507">Shared Pointer implementation</a></li>
<li>18/Apr/2013 &ndash; <a href="http://codereview.stackexchange.com/q/25214/507">Request for review: reference counting smart pointer</a></li>
<li>20/May/2013 &ndash; <a href="http://codereview.stackexchange.com/q/26353/507">Efficient smart pointer implementation in C++</a></li>
<li>11/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/29629/507">C++98 Unique Pointer Implementation</a></li>
<li>14/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/29734/507">I wrote a class to implement auto_ptr</a></li>
<li>28/Aug/2013 &ndash; <a href="http://codereview.stackexchange.com/q/30398/507">yet another shared pointer</a></li>
<li>04/Mar/2014 &ndash; <a href="http://codereview.stackexchange.com/q/43472/507">Smart pointer implementation</a></li>
<li>13/May/2014 &ndash; <a href="http://codereview.stackexchange.com/q/49672/507">One more shared pointer</a></li>
<li>14/Jun/2014 &ndash; <a href="http://codereview.stackexchange.com/q/54220/507">Is this a meaningful Intrusive Pointer Class?</a></li>
<li>04/Aug/2014 &ndash; <a href="http://codereview.stackexchange.com/q/59004/507">Simple shared pointer</a></li>
<li>08/Oct/2014 &ndash; <a href="http://codereview.stackexchange.com/q/65127/507">Smart but simple pointers</a></li>
<li>15/Nov/2014 &ndash; <a href="http://codereview.stackexchange.com/q/69943/507">Simple auto_ptr</a></li>
<li>19/Dec/2014 &ndash; <a href="http://codereview.stackexchange.com/q/74166/507">Yet another smart pointer implementation for learning</a></li>
</ul>


<p>Writing you own implementation of a smart pointer is a bad idea (IMO). The standardization and testing of smart pointers was a nine years process through <a href="http://www.boost.org/">boost</a> with <a href="http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/shared_ptr.htm">boost::shared_ptr</a> and <a href="http://www.boost.org/doc/libs/1_57_0/libs/smart_ptr/scoped_ptr.htm">boost::scoped_ptr</a>. This finally resulted in standardized versions being released in C++11: <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> and <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>.</p>

<p>I would even say even dislike the smart pointer as a learning device; it seems like a very simple project for a newbie, but in reality (as indicated by the nine year standardization processes) to get it working correctly in all contexts is rather a complex in-devour.</p>

<p>But; because it is such a frequent request for review I want take a look at smart pointers as a teaching exercise. So I want to step through the processes of building a smart pointer and look at some of the common mistakes that I see (and probably make a few as I go).</p>

<h2>First Bash</h2>

<p>So lets get started. The two most common smart pointers are <code>unique</code> and <code>shared</code>. So lets start with the one that seems the simplest (<code>unique</code>)and see where we go.</p>

<p>It would seem that we could bash out a quick unique pointer like this:</p>

<pre><code>namespace ThorsAnvil
{
    template&lt;typename T&gt;
    class UP
    {
        T*   data;
        public:
            UP(T* data)
                : data(data)
            {}
            ~UP()
            {
                delete data;
            }
            T* operator-&gt;() {return data;}
            T&amp; operator*()  {return *data;}
            T* release()
            {
                T* result = nullptr;
                std::swap(result, data);
                return result;
            }
    };
}
</code></pre>

<h3>Problem 1: Rule of Three Violation</h3>

<p>The first problem here is that we are not obeying the &ldquo;rule of three&rdquo;. Since we have a destructor that does memory management we should also handle the copy constructor and assignment operator. Otherwise the following is allowed and will cause undefined behavior:</p>

<pre><code>int test1()
{
    ThorsAnvil::SP   sp1&lt;int&gt;(new int(5));
    ThorsAnvil::SP   sp2&lt;int&gt;(sp1);  // copy construction

             // Here the compiler generated copy constructor
             // kicks in and does a member wise copy of sp1
             // into sp2. That in itself is not a problem.
 }
 // But when sp2 goes out of scope its destructor kicks in
 // and deletes the pointer. When sp1 subsequently follows
 // sp2 out of scope it will also call delete on the same
 // pointer (as they share a copy of the pointer).
 // 
 // This is known as a double delete and causes
 // undefined behavior (UB).
</code></pre>

<p> The assignment operator is slightly worse:</p>

<pre><code>int test2()
{
    ThorsAnvil::SP   sp1&lt;int&gt;(new int(5));
    ThorsAnvil::SP   sp2&lt;int&gt;(new int(6));

    sp2 = sp1; // Assignment operation.

             // Here the compiler generated assignment 
             // operator kicks in and does a member wise 
             // assignment of sp1 into sp2.
             //
             // The main problem with the assignment here
             // is that we have lost the original pointer
             // that sp2 was holding.
 }
 // Same issues with double delete as the copy constructor.
</code></pre>

<p>This is caused by the compiler atomically generating default implementations of certain methods (see discussion on the rule of three) if the user does not explicitly specify otherwise. I have heard this described as a language bug; but I have to disagree with that sentiment, as these compiler generated methods do exactly as you would expect in nearly all situations. The one exceptions is when the class contains &ldquo;owned raw pointers&rdquo;.</p>

<h3>Problem 2: Implicit construction.</h3>

<p>The next issue is caused by C++ tendency to eagerly convert one type to another if given half a chance. If your class contains a constructor that takes a single argument then the compiler will use this as a way of converting one type to another.</p>

<p><strong><em>Example</em></strong>:</p>

<pre><code>void takeOwner1(ThorsAnvil::UP&lt;int&gt; x)
{}
void takeOwner2(ThorsAnvil::UP&lt;int&gt; const&amp; x)
{}
void takeOwner3(ThorsAnvil::UP&lt;int&gt;&amp;&amp; x)
{}
int main()
{
    int*   data = new int(7);

    takeOwner1(data);
    takeOwner2(data);
    takeOwner3(data);
}
</code></pre>

<p>Though none of the functions in the example take an <code>int pointer</code> as a parameter; the compiler sees that it can convert an <code>int*</code> into an object of type <code>ThorsAnvil::UP&lt;int&gt;</code> via the single argument constructor and builds temporary objects to facilitate the calling of the function.</p>

<p>In the case of smart pointers, that take ownership of the object passed in the constructor, this can be a problem because the lifetime of a temporary object is the containing statement (with a few exceptions that we will cover in another article). A a simple rule of thumb you can think of the lifespan of a temporary ending at the <code>';'</code>.</p>

<pre><code>takeOwner1(data);

// You can think of this as functionally equivalent to:

{
    ThorsAnvil::UP&lt;int&gt; tmp(data);
    takeOwner1(tmp);
}
</code></pre>

<p>The problem here is that when <code>tmp</code> goes out of scope its destructor will call delete on the pointer. Thus <code>data</code> is now pointing at memory that has been destroyed (and thus no longer belongs to the application). Any further use of <code>data</code> is going to potentially cause problems (and I am being generous using the word potentially).</p>

<p>This feature can be quite useful (when you want this conversion to happen easily, see std::string). But you should definitely be aware of it and think carefully about creating single argument constructors.</p>

<h3>Problem 3: Null de-referencing</h3>

<p>I think it is obvious that <code>operator*</code> has an issue with dereferencing a Null pointer here:</p>

<pre><code>            T&amp; operator*()  {return *data;}
</code></pre>

<p>But it is not quite as obvious that <code>operator-&gt;</code> is also going to cause dereferencing of the pointer here:</p>

<pre><code>            T* operator-&gt;() {return data;}
</code></pre>

<p>There are a couple of solutions to this problem. You can check <code>data</code> and throw an exception if it is a Null pointer, or alternatively you can make it a pre-condition on the usage of the smart pointer (ie it is the responsibility of the user to either know or check before using methods).</p>

<p>The standard has chosen to go with a pre-condition (a very common C++ practice: do not impose an overhead on all your users (to spare problems for the beginner), but rather provide a mechanism for those that need; so they can choose to pay the overhead when they need to and not every time). We can do the same here but we have not provided any mechanism for the user to check the state of the smart pointer.</p>

<h3>Problem 4: Const Correctness</h3>

<p>When accessing the owned object via a smart pointer we are not affecting the state of our smart pointer so any member that basically returns the object (without changing the state of the smart pointer) should be marked cost.</p>

<pre><code>            T* operator-&gt;() {return data;}
            T&amp; operator*()  {return *data;}
</code></pre>

<p>So these two methods should really be declared as:</p>

<pre><code>            T* operator-&gt;() const {return data;}
            T&amp; operator*()  const {return *data;}
</code></pre>

<h2>Summary</h2>

<p>So the in this initial post we have looked at a typical first attempt at a smart pointer and summarized the common problems I often see when people look to building their own smart pointer.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Loki Astari</span></span>

      








  


<time datetime="2014-12-30T18:41:42-08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/" data-via="LokiAstari" data-counturl="http://lokiastari.com/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/" >Tweet</a>
  
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    
    <ul class="pager">
      
      <li class="previous"><a class="basic-alignment left"
        href="/blog/2014/12/06/nearly-new-year-slash-new-resolution/" title="Previous Post:
        Nearly New Year/New Resolution">&laquo; Nearly New Year/New Resolution</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
    </ul>
  </footer>
</article>

<aside class="sidebar-nav span3">
  
    <section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Recent Posts</li>
    
      <li class="post">
        <a href="/blog/2014/12/30/c-plus-plus-by-example-smart-pointer/">C++ By Example: Smart Pointer</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/06/nearly-new-year-slash-new-resolution/">Nearly New Year/New Resolution</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/12/02/so-you-want-to-learn-c-plus-plus-part-5/">So You Want to Learn C++ Part-5</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/30/switching-to-octopress/">Switching to OctoPress</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/24/so-you-want-to-learn-c-plus-plus-part-4/">So you want to learn C++ Part-4</a>
      </li>
    
  </ul>
</section>
<section class="well">
  <ul id="recent_posts" class="nav nav-list">
    <li class="nav-header">Twitter</li>
    <li class="post">
        <a class="twitter-timeline"  href="https://twitter.com/LokiAstari"  data-widget-id="406713536040030209">Tweets by @LokiAstari</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
    </li>
  </ul>
</section>

<section class="well">
  <ul id="gh_repos" class="nav">
    <li class="nav-header">GitHub Repos</li>
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/Loki-Astari">@Loki-Astari</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        github.showRepos({
            user: 'Loki-Astari',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/asides/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo" class="page-footer"><hr>
<p>
  Copyright &copy; 2015 - Loki Astari -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45976821-1', 'lokiastari.com');
  ga('send', 'pageview');

</script>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
